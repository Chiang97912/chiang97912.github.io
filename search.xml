<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习模型评估方法及代码实现</title>
    <url>/2020/01/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>混淆矩阵（confusion matrix）如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">真实\预测</th>
<th style="text-align:center">正例</th>
<th style="text-align:center">反例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>正例</strong></td>
<td style="text-align:center">TP(真正例)</td>
<td style="text-align:center">FN(假反例)</td>
</tr>
<tr>
<td style="text-align:center"><strong>反例</strong></td>
<td style="text-align:center">FP(假正例)</td>
<td style="text-align:center">TN(真反例)</td>
</tr>
</tbody>
</table>
</div>
<p>TP: 将正例预测为正例（预测正确）；</p>
<p>FN: 将正例预测为负例（预测错误）；</p>
<p>FP: 将负例预测为正例（预测错误）；</p>
<p>TN: 将负例预测为负例（预测正确）。</p>
<p>正例包括 TP、FN；反例包括 TN、FP</p>
<a id="more"></a>
<h2 id="准确率（Accuracy）"><a href="#准确率（Accuracy）" class="headerlink" title="准确率（Accuracy）"></a>准确率（Accuracy）</h2><p>定义：指的是分类正确的样本数量占样本总数的比例</p>
<p>公式：</p>
<script type="math/tex; mode=display">
A=\frac{TP+TN}{TP+TN+FN+FP}</script><p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</div><div class="line">y_pred = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</div><div class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">accuracy_score(y_true, y_pred)</div></pre></td></tr></table></figure>
<h2 id="精确率-Precision"><a href="#精确率-Precision" class="headerlink" title="精确率(Precision)"></a>精确率(Precision)</h2><p>定义：精确率(Precision)，即查准率。通常我们所说的精确率是正例的精确率，<strong>它是被判定为正例的样本中，真正的正例样本的比例。</strong>我们同样可以计算负例的精确率，但是通常没有人这样做。精确率主要用来评测是否<strong>误检</strong>。举个例子，假设一个班级有10个学生，5男5女。我们目标是寻找班级中的女生，返回6个结果分别是男 、 女 、女 、 男 、女 、 男。如果返回的结果中只有3个正确，那么查准率为3/6=0.5。</p>
<p>公式（分类任务）：</p>
<script type="math/tex; mode=display">
P=\frac{TP}{TP+FP}或\frac{TN}{TN+FN}</script><p>在信息检索领域，精确率是返回结果中相关文档的数目与返回结果的数目的比例：</p>
<script type="math/tex; mode=display">
precision=\frac{|\{relevant\ documents\}∩\{retrieved\ documents\}|}{\{retrieved\ documents\}}</script><p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</div><div class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">y_pred = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">precision_score(y_true, y_pred, average=<span class="string">'macro'</span>)</div><div class="line"></div><div class="line">precision_score(y_true, y_pred, average=<span class="string">'micro'</span>)</div><div class="line"></div><div class="line">precision_score(y_true, y_pred, average=<span class="string">'weighted'</span>)</div><div class="line"></div><div class="line">precision_score(y_true, y_pred, average=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<p>注释：</p>
<p>macro 度量：对于n个二分类混淆矩阵，在各混淆矩阵上分别计算精确率和召回率，记（P1,R1），（P2,R2）…（Pn，Rn），再计算平均值，得到宏精确率（macro-P）、宏召回率（macro-R），继而得到宏F1（macro-F1）。</p>
<p>micro度量：对于n个二分类混淆矩阵，先对TP、FN、FP、TN求平均值，再用均值计算得到微精确率（micro-P）、微召回率（micro-P），继而得到微F1（micro-F1）。</p>
<h2 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率(Recall)"></a>召回率(Recall)</h2><p>定义：召回率(Recall)，即查全率。通常我们所说的召回率是正例的召回率，<strong>它是被正确分类的正例样本，占所有正例样本的比例。</strong>我们同样可以计算负例的召回率，但是通常没有人这样做。召回率主要用来评测是否<strong>漏检</strong>。举个例子，假设一个班级有10个学生，5男5女。我们目标是寻找班级中的女生，返回6个结果分别是男 、 女 、女 、 男 、女 、 男。总共有5个女生，返回结果中有3个女生，那么查全率为3/5=0.6。</p>
<p>公式（分类任务）：</p>
<script type="math/tex; mode=display">
R=\frac{TP}{TP+FN}或\frac{TN}{TN+FP}</script><p>在信息检索领域，召回率是返回结果中相关文档的数目与所有相关文档的数目的比例：</p>
<script type="math/tex; mode=display">
precision=\frac{|\{relevant\ documents\}∩\{retrieved\ documents\}|}{\{relevant\ documents\}}</script><p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score</div><div class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">y_pred = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">recall_score(y_true, y_pred, average=<span class="string">'macro'</span>)</div><div class="line"></div><div class="line">recall_score(y_true, y_pred, average=<span class="string">'micro'</span>)</div><div class="line"></div><div class="line">recall_score(y_true, y_pred, average=<span class="string">'weighted'</span>)</div><div class="line"></div><div class="line">recall_score(y_true, y_pred, average=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<h2 id="F1-score"><a href="#F1-score" class="headerlink" title="F1_score"></a>F1_score</h2><p>定义：精确率和召回率的调和平均值。</p>
<p>公式：</p>
<script type="math/tex; mode=display">
\frac{1}{F1}=\frac{1}{2}.(\frac{1}{P}+\frac{1}{R})，即F1=\frac{2\times P\times R}{P+R}=\frac{2TP}{2TP+FP+FN}</script><p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</div><div class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">y_pred = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">f1_score(y_true, y_pred, average=<span class="string">'macro'</span>)</div><div class="line"></div><div class="line">f1_score(y_true, y_pred, average=<span class="string">'micro'</span>)</div><div class="line"></div><div class="line">f1_score(y_true, y_pred, average=<span class="string">'weighted'</span>)</div><div class="line"></div><div class="line">f1_score(y_true, y_pred, average=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<h2 id="ROC和AUC"><a href="#ROC和AUC" class="headerlink" title="ROC和AUC"></a>ROC和AUC</h2><p>定义： <strong>ROC曲线</strong>，是以FPR(False Positive Rate, 召回率) 为横轴、TPR(True Positive Rate, 取伪率)为纵轴，衡量二分类系统性能的曲线。分类器对分类的置信度一般设为50%，即置信度超过50%认为是正例，低于50%认为是反例。依次改变这个置信度为10%~100%，会得到一组不同的混淆矩阵，取其中的FPR和TPR值组成坐标，连接这些值，就得到ROC曲线。<strong>ROC曲线与X轴围成的图形面积可以作为一个综合衡量指标，即AUC（Area Under Curve，曲线下面积）</strong>。AUC越大，曲线就越凸，分类器的效果也就越好。ROC曲线反映了分类器对正例的覆盖能力和对负例的覆盖能力之间的权衡。</p>
<p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc, roc_auc_score</div><div class="line"></div><div class="line">y = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</div><div class="line">pred = np.array([<span class="number">0.1</span>,<span class="number">0.4</span>,<span class="number">0.35</span>,<span class="number">0.8</span>])</div><div class="line">fpr,tpr,thresholds = roc_curve(y,pred,pos_label=<span class="number">2</span>)</div><div class="line">result = auc(fpr,tpr)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<h2 id="AP-MAP"><a href="#AP-MAP" class="headerlink" title="AP/MAP"></a>AP/MAP</h2><p>定义：我们首先引入PR曲线概念。<strong>PR曲线</strong>（Precision-recall曲线）与ROC曲线的区别是横轴和纵轴不同，PR曲线的横轴Recall也就是TPR，反映了分类器对正例的覆盖能力。而纵轴Precision的分母是识别为正例的数目，而不是实际正例数目。Precision反映了分类器预测正例的准确程度。那么，PR曲线反映了分类器对正例的识别准确程度和对正例的覆盖能力之间的权衡。对于随机分类器而言，其Precision固定的等于样本中正例的比例，不随recall的变化而变化。与AUC相似，<strong>AP（Average Precision）就是PR曲线与X轴围成的图形面积</strong>，</p>
<p>若PR曲线为连续型，则：</p>
<script type="math/tex; mode=display">
AP=\int_{0}^{1} PR\, \mathrm{d}r</script><p>若PR曲线为离散型，则：</p>
<script type="math/tex; mode=display">
AP=\sum_{k=1}^n P(K)\Delta r(k)</script><p>在信息检索领域，我们引入<strong>MAP</strong>(Mean Average Precision, 均值平均精度)，</p>
<script type="math/tex; mode=display">
MAP=\frac{\sum_{q=1}^Q AP(q)}{Q}</script><p>其中Q为查询的总次数。</p>
<p>AP计算方法：前面给出的是AP的定义式，下面我们将介绍在信息检索领域计算AP的方法。首先求出每个位置上的精确率（Precision），然后求所有的位置的精确率（Precision）的平均值。如果该位置的文档是不相关的则该位置 Precision=0。</p>
<script type="math/tex; mode=display">
AP=\frac{\sum_{k=1}^n (P(k)\times rel(k))}{number\ of\ relevant\ documents}</script><p>注：其中k是返回结果序列的排列次序，n是返回结果的数目，P(k)是返回序列中从第k个文档处截断的精确率，rel(k)是指示函数，如果第k个文档为相关文档则rel(k)=1，否者rel(k)=0。</p>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Prediction</strong></th>
<th><strong>Correctness</strong></th>
<th><strong>Points</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>wrong</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>right</td>
<td>1 / 2</td>
</tr>
<tr>
<td>3</td>
<td>right</td>
<td>2 / 3</td>
</tr>
<tr>
<td>4</td>
<td>wrong</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>right</td>
<td>3 / 5</td>
</tr>
<tr>
<td>6</td>
<td>wrong</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>wrong</td>
<td>0</td>
</tr>
<tr>
<td>8</td>
<td>wrong</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>right</td>
<td>4 / 9</td>
</tr>
<tr>
<td>10</td>
<td>wrong</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>上表中Prediction列表示文档的得分排序结果，Correctness列表示结果的正确性，Points列为精确率得分。那么我们将计算得到AP=(0+1/2+2/3+0+3/5+0+0+0+4/9+0)/4=0.55。</p>
<p>MAP计算方法：主集合的平均准确率(MAP)是每个主题的平均准确率（AP）的平均值。假设在测试集中一共有k个类别。我们先算出我们的模型对于每个类别的AP，然后将这些AP相加在一起再除以所有类别的数量k，就可以得到最终模型的MAP。</p>
<p>例如：假设有两个主题，主题1有4个相关网页，主题2有3个相关网页。对于主题1检索出4个相关网页，其rank分别为1, 2, 4, 7，平均准确率为(1/1+2/2+3/4+4/7)/4=0.83；对于主题2检索出3个相关网页，其rank分别为1,3,5，平均准确率为(1/1+2/3+3/5+0+0)/5=0.45。则MAP= (0.83+0.45)/2=0.64。</p>
<p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> average_precision_score</div><div class="line">y_true = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</div><div class="line">y_scores = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</div><div class="line">result = average_precision_score(y_true, y_scores)  <span class="comment"># 计算AP</span></div><div class="line">print(result)</div></pre></td></tr></table></figure>
<h2 id="MRR"><a href="#MRR" class="headerlink" title="MRR"></a>MRR</h2><p>定义：MRR(Mean Reciprocal Rank, 平均倒数排名)把标准答案在搜索结果中分数的排序取倒数作为它的准确度，再对所有的问题取平均。例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Query</th>
<th style="text-align:left">Results</th>
<th style="text-align:center">Correct response</th>
<th style="text-align:center">Rank</th>
<th style="text-align:center">Reciprocal Rank</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td style="text-align:left">catten, cati, <strong>cats</strong></td>
<td style="text-align:center">cats</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1/3</td>
</tr>
<tr>
<td>torus</td>
<td style="text-align:left">torri, <strong>tori</strong>, toruses</td>
<td style="text-align:center">tori</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1/2</td>
</tr>
<tr>
<td>virus</td>
<td style="text-align:left"><strong>viruses</strong>, virii, viri</td>
<td style="text-align:center">viruses</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>注：黑体为返回结果中最匹配的一项</p>
<p>上表中的MRR=(1/3 + 1/2 + 1)/3 = 11/18=0.61</p>
<p>公式：</p>
<script type="math/tex; mode=display">
MRR=\frac{1}{Q}\sum_{i=1}^{|Q|} \frac{1}{rank_i}</script><p>其中|Q|是查询个数，$rank_i$是第i个查询相对于第一个相关的结果所在的排列位置。</p>
<p>scikit-learn接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> label_ranking_average_precision_score</div><div class="line">y_true = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</div><div class="line">y_score = np.array([[<span class="number">0.75</span>, <span class="number">0.5</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0.1</span>]])</div><div class="line">result = label_ranking_average_precision_score(y_true, y_score)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<h2 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h2><p>定义：NDCG(Normalized Discounted Cumulative Gain, 归一化折损累计增益)，在MAP中，四个文档和query要么相关，要么不相关，即相关度只能是0或1。NDCG对MAP进行了改进，相关度分成从0到r等级。当取r=5时，等级设定如下图所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Relevance Rating</th>
<th>Gain</th>
</tr>
</thead>
<tbody>
<tr>
<td>Perfect</td>
<td>$31=2^5-1$</td>
</tr>
<tr>
<td>Excellent</td>
<td>$15=2^4-1$</td>
</tr>
<tr>
<td>Good</td>
<td>$7=2^3-1$</td>
</tr>
<tr>
<td>Fair</td>
<td>$3=2^2-1$</td>
</tr>
<tr>
<td>xxx</td>
<td>$1=2^1-1$</td>
</tr>
<tr>
<td>Bad</td>
<td>$0=2^0-1$</td>
</tr>
</tbody>
</table>
</div>
<p>我们将这些增益相加就是<strong>CG</strong>(Cumulative Gain，累计增益,),CG就是将每个推荐结果相关性的分支累加后作为整个推荐列表的得分。</p>
<script type="math/tex; mode=display">
CG_k=\sum_{i=1}^k{rel_i}</script><p>其中$rel_i$表示处于位置i的推荐结果的相关性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Relevance Rating</th>
<th>Gain</th>
<th>Cumulative Gain</th>
</tr>
</thead>
<tbody>
<tr>
<td>#1</td>
<td><a href="http://abc.go.com/" target="_blank" rel="external">http://abc.go.com/</a></td>
<td>31</td>
<td>31=31x1</td>
</tr>
<tr>
<td>#2</td>
<td><a href="http://www.abcteach.com/" target="_blank" rel="external">http://www.abcteach.com/</a></td>
<td>3</td>
<td>34=31+3</td>
</tr>
<tr>
<td>#3</td>
<td><a href="http://abcnews.go.com/sections/scitech/" target="_blank" rel="external">http://abcnews.go.com/sections/scitech/</a></td>
<td>15</td>
<td>49=31+3+15</td>
</tr>
<tr>
<td>#4</td>
<td><a href="http://www.abc.net.au/" target="_blank" rel="external">http://www.abc.net.au/</a></td>
<td>15</td>
<td>64=31+3+15+15</td>
</tr>
<tr>
<td>#5</td>
<td><a href="http://abcnews.go.com/" target="_blank" rel="external">http://abcnews.go.com/</a></td>
<td>15</td>
<td>79=31+3+15+15+15</td>
</tr>
<tr>
<td>#6</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>考虑到一般情况下用户会优先点选排在前面的搜索结果，所以应该引入一个折算因子(discounting factor)，这时将计算得到<strong>DCG</strong>(Discounted Cumulative Gain)值。</p>
<script type="math/tex; mode=display">
DCG_k=\sum_{i=1}^k \frac{2^{rel_i}-1}{log_2 (i+1)}</script><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Relevance Rating</th>
<th>Gain</th>
<th>Discounted Cumulative Gain</th>
</tr>
</thead>
<tbody>
<tr>
<td>#1</td>
<td><a href="http://abc.go.com/" target="_blank" rel="external">http://abc.go.com/</a></td>
<td>31</td>
<td>31=31x1</td>
</tr>
<tr>
<td>#2</td>
<td><a href="http://www.abcteach.com/" target="_blank" rel="external">http://www.abcteach.com/</a></td>
<td>3</td>
<td>32.9=31+3x0.63</td>
</tr>
<tr>
<td>#3</td>
<td><a href="http://abcnews.go.com/sections/scitech/" target="_blank" rel="external">http://abcnews.go.com/sections/scitech/</a></td>
<td>15</td>
<td>40.4=32.9+15x0.50</td>
</tr>
<tr>
<td>#4</td>
<td><a href="http://www.abc.net.au/" target="_blank" rel="external">http://www.abc.net.au/</a></td>
<td>15</td>
<td>46.9=40.4+15x0.43</td>
</tr>
<tr>
<td>#5</td>
<td><a href="http://abcnews.go.com/" target="_blank" rel="external">http://abcnews.go.com/</a></td>
<td>15</td>
<td>52.7=46.9+15x0.39</td>
</tr>
<tr>
<td>#6</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>最后我们对DCG进行归一化得到<strong>NDCG</strong>(Normalized Discounted Cumulative Gain,归一化折损累计增益)。</p>
<script type="math/tex; mode=display">
NDCG_k=\frac{DCG_k}{IDCG_k}</script><p>其中IDCG(Ideal DCG)，指推荐系统为某一用户返回的最好推荐结果列表，即假设返回结果按照相关性排序，最相关的结果放在前面，此序列的DCG为IDCG。因此DCG的值介于(0, IDCG]，故NDCG的值介于(0,1]。</p>
<h2 id="评估方法实现"><a href="#评估方法实现" class="headerlink" title="评估方法实现"></a>评估方法实现</h2><script src="https://gist.github.com/Chiang97912/5ebca5f3fa58eff4a096119dd356e032.js"></script>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://en.wikipedia.org/wiki/Precision_and_recall" target="_blank" rel="external">Precision and recall</a></p>
<p>[2]:  <a href="https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval" target="_blank" rel="external">https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval</a>)</p>
<p>[3]:  <a href="https://www.cnblogs.com/shixiangwan/p/7215926.html" target="_blank" rel="external">Precision/Recall、ROC/AUC、AP/MAP等概念区分</a> </p>
<p>[4]: <a href="https://blog.csdn.net/lightty/article/details/47079017" target="_blank" rel="external">IR的评价指标-MAP,NDCG和MRR</a></p>
<p>[5]: <a href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank" target="_blank" rel="external">Mean reciprocal rank</a></p>
<p>[6]: <a href="https://blog.csdn.net/GeForce_GTX1080Ti/article/details/78877318" target="_blank" rel="external">二分类模型评估指标的计算方法与代码实现</a></p>
<p>[7]: <a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain" target="_blank" rel="external">Discounted cumulative gain</a></p>
<p>[8]: <a href="https://www.cnblogs.com/Alex0111/p/8482786.html" target="_blank" rel="external">一个评测指标就是MAP(Mean Average Precision)平均精度均值。</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>模型评估</tag>
        <tag>Accuracy</tag>
        <tag>Precision</tag>
        <tag>Recall</tag>
        <tag>F1</tag>
        <tag>ROC</tag>
        <tag>AUC</tag>
        <tag>MAP</tag>
        <tag>MRR</tag>
        <tag>NDCG</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级Git服务Gogs搭建教程</title>
    <url>/2019/12/30/%E8%BD%BB%E9%87%8F%E7%BA%A7Git%E6%9C%8D%E5%8A%A1Gogs%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gogs是一个类似于Gitlab的开源Git服务，它具有易安装、跨平台、轻量级等特点。相比于Gitlab它的资源占有率极低，对于个人开发者或者小型团队是非常实用的一款Git服务。</p>
<h2 id="创建系统用户"><a href="#创建系统用户" class="headerlink" title="创建系统用户"></a>创建系统用户</h2><p>创建新的系统用户 “git”，并切换为 “git” 用户:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo useradd -m git</div><div class="line">sudo su - git</div></pre></td></tr></table></figure>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>创建新的数据库并命名为gogs：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt;create database gogs;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装Gogs"><a href="#安装Gogs" class="headerlink" title="安装Gogs"></a>安装Gogs</h2><p>本文以v0.11.53 版本为例，最新版本读者可以前往<a href="https://dl.gogs.io/" target="_blank" rel="external">dl.gogs.io</a>查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wget https://dl.gogs.io/0.11.53/gogs_0.11.53_linux_amd64.tar.gz</div><div class="line">tar xzvf gogs_0.11.53_linux_amd64.tar.gz</div></pre></td></tr></table></figure>
<h2 id="运行Gogs"><a href="#运行Gogs" class="headerlink" title="运行Gogs"></a>运行Gogs</h2><p>进入解压后的文件夹，然后执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./gogs web</div></pre></td></tr></table></figure>
<p>最后浏览器访问http://<ip>:3000完成相应的配置即可。</ip></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Gogs不支持移动适配，但是它的开源分支Gitea支持，且Gitea的安装流程基本和Gogs一致。</p>
]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gogs</tag>
        <tag>Gitea</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyinstaller打包Python程序攻略</title>
    <url>/2019/08/25/Pyinstaller%E6%89%93%E5%8C%85Python%E7%A8%8B%E5%BA%8F%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="PyInstaller基本使用方法"><a href="#PyInstaller基本使用方法" class="headerlink" title="PyInstaller基本使用方法"></a>PyInstaller基本使用方法</h1><p>下面列举几个常见的可选参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pyinstaller [options] my_script.py</div><div class="line">[options]:</div><div class="line">	-h 显示帮助并退出</div><div class="line">	-D 生成一个文件夹，其中包含一个可执行文件（默认）</div><div class="line">	-F 生成单个可执行文件</div><div class="line">	-w 生成一个无命令行界面的程序</div><div class="line">	-i file.ico 指定图标</div><div class="line">	--add-data SRC;DEST 在程序中用到的其他（非二进制）文件，不建议用</div><div class="line">	--hidden-import MODULENAME 在程序中隐式导入的库，可多次使用</div><div class="line">	--exclude-module MODULENAME 不希望导入的库，可多次使用</div></pre></td></tr></table></figure>
<p>更详细的使用方法可以参看<a href="https://pyinstaller.readthedocs.io/en/stable/" target="_blank" rel="external">官方手册</a>，本文不再赘述。</p>
<h1 id="问题：打包后程序体积太大"><a href="#问题：打包后程序体积太大" class="headerlink" title="问题：打包后程序体积太大"></a>问题：打包后程序体积太大</h1><p>由于笔者使用的是Anaconda作为Python环境，最近有个项目需要将Python代码打包成可执行文件。在之前的需求中没有使用科学计算库（例如numpy、pandas等）所以打包出来的结果也就10M左右，完全可以接受。但是最近在项目中使用了numpy等科学计算库之后，程序打包的结果接近1G左右，这样的打包结果简直令人窒息。这里主要有两个解决方案：1. 使用虚拟环境打包 2. 使用纯净版本的Python打包</p>
<p>推荐使用第二种方法。</p>
<a id="more"></a>
<h1 id="使用虚拟环境打包"><a href="#使用虚拟环境打包" class="headerlink" title="使用虚拟环境打包"></a>使用虚拟环境打包</h1><p>Python虚拟环境有Anaconda、virtualenv以及pipenv，但是Anaconda打包的程序体积太大，所以我们需要避开Anaconda。本文主要介绍的虚拟环境是pipenv，它是pip和virtualenv的结合，所以使用起来也更加方便，另外值得一提的是，pipenv和requests（Python网络请求包）是同一个作者。</p>
<h2 id="Pipenv使用教程"><a href="#Pipenv使用教程" class="headerlink" title="Pipenv使用教程"></a>Pipenv使用教程</h2><ul>
<li>安装pipenv</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pip install  pipenv</div></pre></td></tr></table></figure>
<ul>
<li>创建虚拟环境</li>
</ul>
<p>首先进入你的项目所在目录，然后输入下面的命令安装虚拟环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pipenv install --python path\to\python</div></pre></td></tr></table></figure>
<p>注： “path\to\python”是python.exe可执行程序的路径，可以是Anaconda版本的Python也可以是本地纯净版本的Python。因为我们需要避开Anaconda所以读者最好自己前往Python官网下载纯净版本的Python，然后通过上面命令安装虚拟环境。</p>
<ul>
<li>激活虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pipenv shell</div></pre></td></tr></table></figure>
<p>输入上面的命令之后我们就进入了虚拟环境，然后我们可以像平时一样使用Python。</p>
<ul>
<li>安装依赖库</li>
</ul>
<p>在虚拟环境下安装 Pyinstaller 和你自己的脚本依赖的第三方库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pipenv install pyinstaller</div><div class="line">pipenv install numpy</div><div class="line">pipenv install pandas</div><div class="line">pipenv install matplotlib</div></pre></td></tr></table></figure>
<p>当然也可以进入虚拟环境后直接使用pip进行安装。</p>
<h2 id="问题：ModuleNotFoundError"><a href="#问题：ModuleNotFoundError" class="headerlink" title="问题：ModuleNotFoundError"></a>问题：ModuleNotFoundError</h2><p>pyinstaller打包成功后运行程序提示ModuleNotFoundError: No module named ‘distutils’错误解决办法。</p>
<p>问题分析：由于pandas需要调用distutils库（Python自带），但是最新版本的virtualenv和pyinstaller存在兼容性问题，即打包的时候会遗漏distutils库，目前这个BUG还没有得到解决。当然Github上也有很多解决办法，具体可以参考<a href="https://github.com/pyinstaller/pyinstaller/issues/4064" target="_blank" rel="external">这里</a>。</p>
<p>解决方法：由于16.1版本的virtualenv可以正常使用，所以我们可以降级安装virtualenv。1. 首先我们需要卸载新版的virtualenv，然后安装16.1版本的virtualenv；2. 卸载原来的虚拟环境，然后使用16.1版本的virtualenv重新安装虚拟环境（使用pipenv安装）；3. 最后安装相关的依赖库重新打包即可。</p>
<h1 id="使用纯净版本的Python打包"><a href="#使用纯净版本的Python打包" class="headerlink" title="使用纯净版本的Python打包"></a>使用纯净版本的Python打包</h1><p>由于本地已经存在Anaconda环境，所以如果我们想再安装纯净版本的Python可以使用虚拟机，但是使用虚拟机安装Python需要安装虚拟机软件，然后安装Windows镜像，步骤过于繁琐，所以我们可以另辟蹊径——使用临时环境变量。</p>
<p>首先前往Python官网下载纯净的Python环境并安装到本地，然后我们可以通过下面的批处理脚本设置临时环境变量，为了方便可以将下面的脚本保存到batch脚本文件中（例如命名为set_python_path.bat），并将该脚本放到c:\windows中，这样我们就可以在任何目录下切换Python环境了。</p>
<p>set_python_path.bat:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@echo off</div><div class="line"></div><div class="line">set conda_path=d:\anaconda3</div><div class="line">set python_path=d:\program files\python36</div><div class="line"></div><div class="line">rem Approach one: Replace the anaconda installation path with the new python installation path</div><div class="line">call call set path=%%path:%conda_path%=%python_path%%%</div><div class="line"></div><div class="line">rem Approach two: Let the new python installation path overwrite the anaconda installation path</div><div class="line">rem set path=%python_path%;%python_path%\Scripts;%path%</div></pre></td></tr></table></figure>
<p>上面的代码中conda_path是Anaconda的安装路径，python_path是纯净版本的Python安装路径。设置临时的Python环境变量主要有两种方法：方法一是替换环境变量中Anaconda安装路径为纯净版本的Python安装路径；方法二是将纯净版本的Python安装路径放到所有路径之前这样就可以覆盖Anaconda的路径。</p>
<p>我们在运行完上面的脚本之后就可以切换到新的Python环境，然后安装Pyinstaller和相关的依赖包进行打包。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>使用上面两者方法之一，原先接近1G的程序，现在只有40M左右。</p>
<p>Enjoy it!</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Pyinstaller</tag>
        <tag>python程序打包</tag>
        <tag>pipenv</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VIM作为IDE</title>
    <url>/2019/08/01/%E4%BD%BF%E7%94%A8VIM%E4%BD%9C%E4%B8%BAIDE/</url>
    <content><![CDATA[<h1 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h1><h2 id="插件管理器"><a href="#插件管理器" class="headerlink" title="插件管理器"></a>插件管理器</h2><p>VIM的插件管理器主要有vim-plug和vundle</p>
<h2 id="Vim-plug"><a href="#Vim-plug" class="headerlink" title="Vim-plug"></a>Vim-plug</h2><ol>
<li><p>首先下载vim-plug，可以去<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="external">github</a>下载</p>
</li>
<li><p>下载完成后解压压缩包将plug.vim复制到vim安装目录下的autoload文件夹下，即可完成vim-plug的安装。</p>
</li>
<li>使用管理员身份运行gvim,，然后点击gvim的“编辑”——“启动设定”，打开_vimrc配置文件。</li>
</ol>
<h3 id="插件安装示例"><a href="#插件安装示例" class="headerlink" title="插件安装示例"></a>插件安装示例</h3><p>在_vimrc中添加如下的内容，这里以vim-plug下载<strong>nerdtree</strong>插件为例。设置完成后保存设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">call plug#begin(&apos;~/.vim/plugged&apos;) &quot;插件保存的目录</div><div class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123;&apos;on&apos;: &apos;NERDTreeToggle&apos;&#125;  &quot;NERDTree插件</div><div class="line">call plug#end()</div></pre></td></tr></table></figure>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>:PlugStatus</td>
<td>查看插件安装状态</td>
</tr>
<tr>
<td>:PlugInstall</td>
<td>安装在_vimrc中配置的插件。注意命令的大小写，执行后vim-plug会自动克隆并安装插件</td>
</tr>
<tr>
<td>:PlugUpdate</td>
<td>更新插件</td>
</tr>
<tr>
<td>:PlugClean</td>
<td>清理插件（需要先在_vimrc中删除或注释）</td>
</tr>
<tr>
<td>:PlugUpgrade</td>
<td>更新vim-plug</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h2><ol>
<li><p>首先下载vundle，可以去<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="external">github</a>下载</p>
</li>
<li><p>下载完成后解压压缩包到vim安装目录下的bundle文件夹下（没有就新建），即可完成vundle的安装。</p>
</li>
<li>使用管理员身份运行gvim,，然后点击gvim的“编辑”——“启动设定”，打开_vimrc配置文件。</li>
</ol>
<h3 id="插件安装示例-1"><a href="#插件安装示例-1" class="headerlink" title="插件安装示例"></a>插件安装示例</h3><p>在_vimrc中添加如下的内容，这里以vundle下载<strong>nerdtree</strong>插件为例。设置完成后保存设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set rtp+=~/.vim/bundle/Vundle.vim</div><div class="line">call vundle#begin()</div><div class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</div><div class="line">Plugin &apos;scrooloose/nerdtree&apos;</div><div class="line">call vundle#end()</div></pre></td></tr></table></figure>
<h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>:PluginList</td>
<td>查看插件安装状态</td>
</tr>
<tr>
<td>:PluginInstall</td>
<td>安装在_vimrc中配置的插件。注意命令的大小写，执行后vundle会自动克隆并安装插件</td>
</tr>
<tr>
<td>:PluginUpdate</td>
<td>更新插件</td>
</tr>
<tr>
<td>:PluginClean</td>
<td>清理插件（需要先在_vimrc中删除或注释）</td>
</tr>
<tr>
<td>:PluginSearch</td>
<td>搜索插件，例如:PluginSearch xml可以搜到xml相关的插件</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h2 id="Python自动补全"><a href="#Python自动补全" class="headerlink" title="Python自动补全"></a>Python自动补全</h2><p>Python自动补全插件这里主要使用<strong>jedi-vim</strong>，具体配置步骤如下：</p>
<p>在_vimrc中添加如下的内容，设置完成后保存设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;插件管理 vim-plug</div><div class="line">call plug#begin(&apos;~/.vim/plugged&apos;) &quot;插件保存的目录</div><div class="line">Plug &apos;davidhalter/jedi-vim&apos;,</div><div class="line">call plug#end()</div></pre></td></tr></table></figure>
<p>然后在gvim中输入<code>:PlugInstall</code>安装jedi-vim插件</p>
<p>注意:</p>
<ol>
<li><p>Vim和版本一定要和Python相匹配，即32位Vim配32位Python, 64位Vim配64位Python。</p>
</li>
<li><p>Vim使用Python编译的版本一定要和电脑上安装的Python版本对应，可能会出现如下错误：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Error: jedi-vim failed to initialize Python: jedi-vim requires Vim with support for Python 2 or 3. (in function jedi#init_python[4]..48_init_python, line 10)</div></pre></td></tr></table></figure>
<p>或者在gvim中输入<code>:python3 print(&quot;Hello world&quot;)</code>出现如下类似的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">E370: Could not load library python37.dll</div><div class="line">E263: Sorry, this command is disabled, the Python library could not be loaded.</div></pre></td></tr></table></figure>
<p>那么可以在_vimrc中添加如下命令指定Python3版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set pythonthreedll=python36.dll</div></pre></td></tr></table></figure>
<p>由于笔者安装的vim8.1使用的是Python3.7编译，但是电脑环境装的是Python3.6，我们可以通过上面配置来解决Windows环境中gvim不支持python3.6的问题。</p>
<h2 id="C-C-自动补全"><a href="#C-C-自动补全" class="headerlink" title="C/C++自动补全"></a>C/C++自动补全</h2><p>C/C++自动补全插件这里主要使用ctags + OmniCppComplete方案，具体配置步骤如下：</p>
<p>Ctags 全名 Exuberant Ctags，是一个独立的程序。它可以为各种语言的源代码生成语言元素（language object）索引文件。对于 C/C++ 而言，就是把源代码中的各种宏、函数、类、类成员等等元素和它们的相关信息生成索引文件，供其它程序使用。OmniCppComplete 是专为 C/C++ 编写的OmniComplete一个补全脚本，它根据 Ctags 生成的索引文件对代码进行补全。</p>
<h3 id="安装Ctags"><a href="#安装Ctags" class="headerlink" title="安装Ctags"></a>安装Ctags</h3><ol>
<li>从<a href="http://ctags.sourceforge.net/" target="_blank" rel="external">Ctags官网</a>下载 Ctags 可执行文件</li>
<li>将下载到的文件（仅 EXE 文件即可）解压到一个目录，例如 C:/ctags</li>
<li>将该目录加入环境变量 PATH</li>
</ol>
<h3 id="生成索引文件"><a href="#生成索引文件" class="headerlink" title="生成索引文件"></a>生成索引文件</h3><p>以生成 C++ 标准库索引文件为例：</p>
<ol>
<li><p>下载专为 Ctags 修改过的 <a href="http://www.vim.org/scripts/script.php?script_id=2358" target="_blank" rel="external">libstdc++ 头文件</a></p>
</li>
<li><p>将其解压到一个目录，例如 C:/ctags/cpp_src</p>
</li>
<li><p>使用命令行进入 D:/ctags/cpp_src 后执行：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ctags -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ -f cpp .</div></pre></td></tr></table></figure>
<p>建议将上一步生成的 C:/ctags/cpp_src/cpp 文件放到一个专门放置索引文件的目录以便后面的统一设置，例如放到 C:/ctags/tags</p>
<p>其它库的索引文件也可以依法炮制，只需切换到该库的 include 文件夹，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ -f &lt;文件名&gt; .</div></pre></td></tr></table></figure>
<h3 id="安装OmniCppComplete"><a href="#安装OmniCppComplete" class="headerlink" title="安装OmniCppComplete"></a>安装OmniCppComplete</h3><ol>
<li>使用插件管理器安装OmniCppComplete</li>
<li>修改VIM配置文件_vimrc，加入如下内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot; ctags 索引文件</div><div class="line">set tags+=C:/ctags/tags/cpp &quot; 指定tags存放路径</div><div class="line"></div><div class="line">&quot; OmniCppComplete</div><div class="line">let OmniCpp_NamespaceSearch = 1</div><div class="line">let OmniCpp_GlobalScopeSearch = 1</div><div class="line">let OmniCpp_ShowAccess = 1</div><div class="line">let OmniCpp_ShowPrototypeInAbbr = 1 &quot; 显示函数参数列表</div><div class="line">let OmniCpp_MayCompleteDot = 1   &quot; 输入 .  后自动补全</div><div class="line">let OmniCpp_MayCompleteArrow = 1 &quot; 输入 -&gt; 后自动补全</div><div class="line">let OmniCpp_MayCompleteScope = 1 &quot; 输入 :: 后自动补全</div><div class="line">let OmniCpp_DefaultNamespaces = [&quot;std&quot;, &quot;_GLIBCXX_STD&quot;]</div><div class="line">&quot; 自动关闭补全窗口</div><div class="line">au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif</div><div class="line">set completeopt=menuone,menu,longest</div><div class="line"></div><div class="line">filetype plugin indent on</div></pre></td></tr></table></figure>
<p>在插入模式编辑 C/C++ 源文件时按下 . 或 -&gt; 或 ::，或者手动按下 Ctrl+X Ctrl+O 后就会弹出自动补全窗口，此时可以用 Ctrl+N 和 Ctrl+P 上下移动光标进行选择。</p>
<h3 id="自动生成tags文件"><a href="#自动生成tags文件" class="headerlink" title="自动生成tags文件"></a>自动生成tags文件</h3><p>omni插件的补全是依赖于tags文件的，因此需要我们手动建立tags文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++</div></pre></td></tr></table></figure>
<p>我们可以通过下面的代码让vim在保存文件后自动生成tags文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">au BufWritePost *.c,*.cpp,*.cc,*.h silent! !ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++</div></pre></td></tr></table></figure>
<p>其中silent!表示静默运行命令，不然每次保存文件的时候，Vim 总是会有一个”ctags 执行完毕“的提示，按任意键确认。</p>
<h2 id="生产力插件"><a href="#生产力插件" class="headerlink" title="生产力插件"></a>生产力插件</h2><h3 id="Python代码检查：flake8"><a href="#Python代码检查：flake8" class="headerlink" title="Python代码检查：flake8"></a>Python代码检查：flake8</h3><ol>
<li>实用插件管理器安装flake8</li>
<li>配置_vimrc文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">au BufWritePost *.py call Flake8()</div></pre></td></tr></table></figure>
<h3 id="注释-取消注释：vim-commentary"><a href="#注释-取消注释：vim-commentary" class="headerlink" title="注释/取消注释：vim-commentary"></a>注释/取消注释：vim-commentary</h3><p>这个插件可以快速注释与反注释多行内容, 但是它的注释符使用的是 commentstring, 默认是 /<em> %s </em>/, 但这个值满足不了Python 和 Shell这样的语言, 在 _vimrc 添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;为python和shell等添加注释</div><div class="line">autocmd FileType python,shell,coffee set commentstring=#\ %s</div><div class="line">&quot;修改注释风格</div><div class="line">autocmd FileType java,c,cpp set commentstring=//\ %s</div></pre></td></tr></table></figure>
<p>普通模式下gcc 指令可以注释/取消注释</p>
<p>可视模式下gc 命令可以注释/撤销注释</p>
<h3 id="缩进提示：indentLine"><a href="#缩进提示：indentLine" class="headerlink" title="缩进提示：indentLine"></a>缩进提示：indentLine</h3><p>indentLine是一款Vim下用于显示缩进指示线的插件。对于Python、Golang等靠代码缩进来标识代码块的语言来说，indentLine提供的缩进指示功能非常有用。indentLine安装之后即可使用，不需要额外的配置。</p>
<p>设置indentLine：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set list lcs=tab:\|\ &quot; 最后面有空格</div><div class="line">let g:indentLine_leadingSpaceChar = &apos;.&apos;</div><div class="line">let g:indentLine_leadingSpaceEnabled = 1</div></pre></td></tr></table></figure>
<h2 id="实用配置"><a href="#实用配置" class="headerlink" title="实用配置"></a>实用配置</h2><h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot; Enable folding</div><div class="line">set foldmethod=syntax  &quot; 语法折叠</div><div class="line">set foldlevelstart=99  &quot; 关闭自动折叠</div></pre></td></tr></table></figure>
<p>zc 关闭折叠<br>zo 打开折叠<br>za 打开/关闭折叠互相切换</p>
<h3 id="系统剪贴板"><a href="#系统剪贴板" class="headerlink" title="系统剪贴板"></a>系统剪贴板</h3><p>通常Vim会忽视系统剪贴板，而使用自带的剪贴板。但是有时候你想从Vim之外的程序中剪切、复制、粘贴文本。你可以通过这行代码访问你的系统剪贴板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set clipboard=unnamed</div></pre></td></tr></table></figure>
<h3 id="禁止生成缓存文件"><a href="#禁止生成缓存文件" class="headerlink" title="禁止生成缓存文件"></a>禁止生成缓存文件</h3><p>每次输入保存命令之后系统都会生成以.un~和.bak结尾的文件，我们可以通过下面的配置禁止vim生成undo文件和备份文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set noundofile</div><div class="line">set nobackup</div><div class="line">set noswapfile</div></pre></td></tr></table></figure>
<h2 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h2><p>主题插件推荐使用flazz/vim-colorschemes</p>
<p>可以使用vim-plug安装，然后再配置_vimrc文件，例如在配置文件中增加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">colorscheme wombat</div></pre></td></tr></table></figure>
<h1 id="Mac-amp-Linux环境"><a href="#Mac-amp-Linux环境" class="headerlink" title="Mac &amp; Linux环境"></a>Mac &amp; Linux环境</h1><h2 id="插件管理器安装"><a href="#插件管理器安装" class="headerlink" title="插件管理器安装"></a>插件管理器安装</h2><p>使用如下命令安装plug-vim插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mkdir -vp ~/.vim/autoload/</div><div class="line">cd ~/.vim/autoload/</div><div class="line">wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</div></pre></td></tr></table></figure>
<h2 id="安装示例"><a href="#安装示例" class="headerlink" title="安装示例"></a>安装示例</h2><p>仍然以NERDTree插件安装为例：</p>
<p>编辑配置文件<code>vim ~/.vimrc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;插件管理 vim-plug</div><div class="line">call plug#begin(&apos;~/.vim/plugged&apos;) &quot;插件保存的目录</div><div class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123;&apos;on&apos;: &apos;NERDTreeToggle&apos;&#125;  &quot;NERDTree插件</div><div class="line">call plug#end()</div></pre></td></tr></table></figure>
<p>其他操作和Windows系统相同。</p>
]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>VIM</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask矩阵在深度学习中的应用</title>
    <url>/2019/08/01/Mask%E7%9F%A9%E9%98%B5%E5%9C%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>mask矩阵是一个由0和1组成的矩阵。在NLP中，一个常见的问题是输入序列长度不等，而mask可以帮助我们处理。虽然RNN等模型可以处理不定长的输入，但是在实践中，需要对输入中长度较短的句子进行填充，即在句尾填充0占位，转换成固定大小的tensor，方便矩阵操作。</p>
<p> 举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">case 1: I like cats.</div><div class="line">case 2: He does not like cats.</div></pre></td></tr></table></figure>
<p>假设默认的序列长度是5，一般会对case 1做pad处理，变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">I like cats &lt;PAD&gt; &lt;PAD&gt;</div></pre></td></tr></table></figure>
<p>在上述例子数字编码后，开始做embedding，而pad也会有embedding向量，但pad本身没有实际意义，参与训练可能还是有害的。因此，有必要维护一个mask tensor来记录哪些是真实的value，上述例子的两个mask如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 1 1 0 0</div><div class="line">1 1 1 1 1</div></pre></td></tr></table></figure>
<p>后续再梯度传播中，mask起到了过滤的作用。</p>
<p>使用TensorFlow实现上述过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">maxlen = <span class="number">5</span></div><div class="line">lengths = [[<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]]</div><div class="line">mask = tf.cast(tf.sequence_mask(lengths, maxlen), tf.float32)</div><div class="line">sess = tf.Session()</div><div class="line">mask = sess.run(mask)</div><div class="line">print(mask)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[[1. 1. 1. 0. 0.]</div><div class="line">  [1. 1. 1. 1. 1.]</div><div class="line">  [1. 1. 1. 1. 0.]]</div><div class="line"></div><div class="line"> [[1. 0. 0. 0. 0.]</div><div class="line">  [1. 1. 1. 0. 0.]</div><div class="line">  [1. 1. 0. 0. 0.]]]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ol>
<li><p>使用mask矩阵是为了让那些被mask掉的tensor不会被更新。一个tensor T和同样大小的mask矩阵M相乘在梯度回传的时候，T对应mask为0的地方梯度为0。因此权重不会被更新。</p>
</li>
<li><p>语言模型中可以防止未来信息泄露</p>
<p>在语言模型中，常常需要从上一个词预测下一个词，而现阶段attention是标配，比如Transformer中的self attention，如果不做mask，在decoder的时候很容易把下一个词的信息泄露了，即按上诉例子，不能在预测like这个词时已经知道like后面的词了。使用mask矩阵可以很好的解决这一问题。</p>
</li>
</ol>
<p>TensorFlow生成mask对角矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsequent_mask</span><span class="params">(size)</span>:</span></div><div class="line">    <span class="string">"Mask out subsequent positions."</span></div><div class="line">    attn_mask = tf.ones([size, size])</div><div class="line">    mask = tf.matrix_band_part(attn_mask, <span class="number">-1</span>, <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> mask </div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line">mask = sess.run(subsequent_mask(<span class="number">10</span>))</div><div class="line">print(mask)</div><div class="line"></div><div class="line"><span class="comment"># Display matrix</span></div><div class="line">plt.matshow(mask)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 0. 0. 0. 0. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 0. 0. 0. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 0. 0. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 0. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 1. 0. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 1. 1. 0. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 1. 1. 1. 0. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 1. 1. 1. 1. 0.]</div><div class="line"> [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://www.zhihu.com/question/305508138/answer/550573253" target="_blank" rel="external">Mask矩阵在深度学习中有哪些应用场景？</a> </p>
<p>[2]: <a href="http://www.linzehui.me/2018/10/12/%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88mask%E7%9F%A9%E9%98%B5/" target="_blank" rel="external">浅谈mask矩阵</a> </p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作记录</title>
    <url>/2019/03/24/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="Git基本配置（git-config）"><a href="#Git基本配置（git-config）" class="headerlink" title="Git基本配置（git config）"></a>Git基本配置（git config）</h2><p>git config可以配置git的参数，可以使用<code>git config --list</code>查看已经配置的git参数。其中有三个级别的保存位置，—system、—global、—local，分别表示所有用户（本系统）、当前用户（全局）、本地配置（当前目录），默认使用—local。</p>
<p><strong>配置用户名及邮箱</strong><br>在使用Git提交前，必须配置用户名和邮箱，这些信息会永久保存到历史记录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git config --global user.name &quot;Peter&quot;</div><div class="line">git config --global user.email Peter@gmail.com</div></pre></td></tr></table></figure>
<ol>
<li><p><strong>创建Git仓库（git init）</strong></p>
<p>可以直接调用<code>git init</code>初始化当前目录，即创建Git仓库。</p>
</li>
<li><p><strong>获取Git仓库（git clone）</strong></p>
<p>如果需要克隆远程仓库，可以使用<code>git clone</code>，比如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git  clone https://github.com/tensorflow/tensorflow.git</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>Git中每个文件都有三种状态：committed、staged、modified。它们之间关系如下：</p>
<p>modified=&gt; staged=&gt; committed</p>
<p>如果你在本地修改了文件，则文件状态就变成modified；如果使用git add命令，文件的状态变成staged；如果使用git commit命令，文件的状态就变成commited。</p>
<p>还有一种文件状态，未跟踪状态（unversioned/untracked），通过使用git add可以把未跟踪状态变更为staged；通过git rm可以将staged或者committed状态变为未跟踪状态。</p>
<p><strong>git status</strong>: 查看在你上次提交之后是否有修改。</p>
<p><strong>git add</strong>: 将想要快照的内容写入缓存区</p>
<p><strong>git commit</strong>: 将缓存区内容添加到仓库中</p>
<p><strong>git rm</strong>: 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p>
<h2 id="查看提交历史（git-log）"><a href="#查看提交历史（git-log）" class="headerlink" title="查看提交历史（git log）"></a>查看提交历史（git log）</h2><p>使用<code>git log</code>查看当前工程的所有提交的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git log --stat      # 仅显示摘要选项</div><div class="line">git log --pretty=oneline        # 定制记录格式</div><div class="line">git log --graph     # 图像化分支和版本更新</div></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>可以使用<code>git remote</code>查看当前的远程库。<br><code>git remote -v</code>可以显示对应的克隆地址。（对于多个远程仓库很有用）</p>
<p><strong>添加远程仓库</strong><br><code>git remote add [short_name] [url]</code>可以添加新的远程仓库。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote add origin https://github.com/username/projectname.git</div></pre></td></tr></table></figure>
<p><strong>修改远程仓库</strong></p>
<p>方法一：修改命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote set-url origin [url]</div></pre></td></tr></table></figure>
<p>注：[url]表示你的Github仓库地址。</p>
<p>方法二：先删除后添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote rm origin</div><div class="line">git remote add origin [url]</div></pre></td></tr></table></figure>
<p>方法三：直接修改config文件</p>
<p><strong>从远程仓库抓取数据</strong><br><code>git fetch [remote-name]</code>可以从远程仓库抓取数据到本地。<br>也可以使用git pull</p>
<p><strong>推送数据到远程仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git push [remote_name] [branch_name]</div></pre></td></tr></table></figure>
<p>默认使用origin和master。</p>
<p>默认使用origin和master。</p>
<p><strong>⭐强制推送数据到远程仓库⭐</strong></p>
<p>我们可以使用<code>git push --force origin master</code>强制推送本地代码到远程仓库，这意味着将覆盖掉远程仓库的代码。（注：—force参数也可以使用-f替代）</p>
<p><strong>查看远程仓库信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote show origin</div></pre></td></tr></table></figure>
<p><strong>远程仓库的删除和重命名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote rename [old_name] [new_name]</div><div class="line">git remote rm [remote_name]</div></pre></td></tr></table></figure>
<h1 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h1><h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>如果需要修改的提交信息是<strong>最后一次提交</strong>并且没有推送（push），那么可以使用如下命令进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git commit --amend -m &quot;your new comment&quot;</div></pre></td></tr></table></figure>
<h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>如果需要修改的<strong>不是最后一次提交</strong>的提交信息，那么我们需要使用git rebase命令</p>
<ol>
<li><p><strong>确定修改的提交</strong></p>
<p>我们可以使用<code>git log</code>命令查看需要修改的提交是<strong>倒数</strong>第几次提交</p>
</li>
<li><p><strong>指定变基对象</strong></p>
<p>使用命令<code>git rebase -i HEAD~n</code>回退到<strong>倒数</strong>第n次提交。运行命令后会进入到编辑器，出现n条commit信息，要修改哪条就将其前面pick改成edit,保存并退出。</p>
</li>
<li><p><strong>修改提交信息</strong></p>
<p>经过变基之后我们可以像第一种情况一样使用<code>git commit --amend</code>命令修改提交信息（可以直接输入<code>git commit --amend</code>然后进入编辑器修改提交内容也可以使用-m直接指定新的提交内容）。</p>
<p>注：变基（rebase）和合并（merge）都是对分支进行操作，它们的不同之处在于变基可以修改历史。执行<code>git commit --amend</code>后会产生一个新的分支，如果需要保留当前分支则需要删除之前的分支，然后将当前分支命名为之前的分支名。</p>
</li>
<li><p><strong>执行变基</strong></p>
<p>执行<code>git rebase –continue</code>，如果提示Successfully rebased and updated则表示变基成功。</p>
</li>
</ol>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="显示所有分支"><a href="#显示所有分支" class="headerlink" title="显示所有分支"></a>显示所有分支</h2><p>使用<code>git branch</code>可显示当前所有分支。<br>可以使用—merged和—no-merged查看已经合并、未合并的分支。</p>
<h2 id="创建及切换分支"><a href="#创建及切换分支" class="headerlink" title="创建及切换分支"></a>创建及切换分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch test    # 创建testing 分支</div><div class="line">git checkout test  # 切换到testing分支</div></pre></td></tr></table></figure>
<p>也可以使用下面命令直接切换并创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git checkout -b test</div></pre></td></tr></table></figure>
<p>注意切换分支时请保持工作目录没有未提交的修改。Git鼓励使用分支，处理完问题之后合并分支即可。</p>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>将test分支合并到master（主分支）上，需要通过下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge test</div></pre></td></tr></table></figure>
<p>合并之后可以使用git branch -d test删除分支。<br>如果合并时存在冲突，需要手工修改。</p>
<h2 id="⭐删除分支⭐"><a href="#⭐删除分支⭐" class="headerlink" title="⭐删除分支⭐"></a>⭐删除分支⭐</h2><p>删除test分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch -d test</div></pre></td></tr></table></figure>
<h2 id="主干更换"><a href="#主干更换" class="headerlink" title="主干更换"></a>主干更换</h2><p>将某个分支设置为主干master，我们可以删除 master，把 dev head 打标成 master。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch -D master</div><div class="line">git checkout -b master</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow共享变量机制理解与应用</title>
    <url>/2019/02/25/tensorflow%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h2><p>Tensorflow创建变量有两种方式：</p>
<ol>
<li>tf.get_variable()</li>
<li>tf.Variable()</li>
</ol>
<p>它们的区别如下：</p>
<p>在 tf.name_scope下时，tf.get_variable()创建的变量名不受 name_scope 的影响，而且在未指定共享变量时，如果重名会报错，tf.Variable()会自动检测有没有变量重名，如果有则会自行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">with tf.name_scope(&apos;name_scope_x&apos;):</div><div class="line">    var1 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div><div class="line">    var3 = tf.Variable(name=&apos;var2&apos;, initial_value=[2], dtype=tf.float32)</div><div class="line">    var4 = tf.Variable(name=&apos;var2&apos;, initial_value=[2], dtype=tf.float32)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    print(var1.name, sess.run(var1))</div><div class="line">    print(var3.name, sess.run(var3))</div><div class="line">    print(var4.name, sess.run(var4))</div><div class="line"># 输出结果：</div><div class="line"># var1:0 [-0.30036557]   可以看到前面不含有指定的&apos;name_scope_x&apos;</div><div class="line"># name_scope_x/var2:0 [ 2.]</div><div class="line"># name_scope_x/var2_1:0 [ 2.]  可以看到变量名自行变成了&apos;var2_1&apos;，避免了和&apos;var2&apos;冲突</div></pre></td></tr></table></figure>
<p>如果使用tf.get_variable()创建变量，且没有设置共享变量，重名时会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">with tf.name_scope(&apos;name_scope_1&apos;):</div><div class="line">    var1 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div><div class="line">    var2 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    print(var1.name, sess.run(var1))</div><div class="line">    print(var2.name, sess.run(var2))</div><div class="line"></div><div class="line"># ValueError: Variable var1 already exists, disallowed. Did you mean </div><div class="line"># to set reuse=True in VarScope? Originally defined at:</div><div class="line"># var1 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><h3 id="基础写法"><a href="#基础写法" class="headerlink" title="基础写法"></a>基础写法</h3><p>如果要共享变量，需要使用tf.variable_scope()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">with tf.variable_scope(&apos;variable_scope_y&apos;) as scope:</div><div class="line">    var1 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div><div class="line">    scope.reuse_variables()  # 设置共享变量</div><div class="line">    var1_reuse = tf.get_variable(name=&apos;var1&apos;)</div><div class="line">    var2 = tf.Variable(initial_value=[2.], name=&apos;var2&apos;, dtype=tf.float32)</div><div class="line">    var2_reuse = tf.Variable(initial_value=[2.], name=&apos;var2&apos;, dtype=tf.float32)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    print(var1.name, sess.run(var1))</div><div class="line">    print(var1_reuse.name, sess.run(var1_reuse))</div><div class="line">    print(var2.name, sess.run(var2))</div><div class="line">    print(var2_reuse.name, sess.run(var2_reuse))</div><div class="line"># 输出结果：</div><div class="line"># variable_scope_y/var1:0 [-1.59682846]</div><div class="line"># variable_scope_y/var1:0 [-1.59682846]   可以看到变量var1_reuse重复使用了var1</div><div class="line"># variable_scope_y/var2:0 [ 2.]</div><div class="line"># variable_scope_y/var2_1:0 [ 2.]</div></pre></td></tr></table></figure>
<p>或者如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">with tf.variable_scope(&apos;foo&apos;) as foo_scope:</div><div class="line">    v = tf.get_variable(&apos;v&apos;, [1])</div><div class="line">with tf.variable_scope(&apos;foo&apos;, reuse=True):</div><div class="line">    v1 = tf.get_variable(&apos;v&apos;)</div></pre></td></tr></table></figure>
<p>还可以像下面这样编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">with tf.variable_scope(&apos;foo&apos;) as foo_scope:</div><div class="line">    v = tf.get_variable(&apos;v&apos;, [1])</div><div class="line">with tf.variable_scope(foo_scope, reuse=True):</div><div class="line">    v1 = tf.get_variable(&apos;v&apos;)</div></pre></td></tr></table></figure>
<h3 id="更优雅的写法"><a href="#更优雅的写法" class="headerlink" title="更优雅的写法"></a>更优雅的写法</h3><p>之前的几种写法是在重复使用（非第一次使用）的时候设置reuse=True来再次调用共享变量作用域（variable_scope），这是一种比较笨的方式，下面使用tf.AUTO_REUSE的写法或许更加优雅：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">with tf.variable_scope(&apos;foo&apos;, reuse=tf.AUTO_REUSE):</div><div class="line">    v = tf.get_variable(&apos;v&apos;, [1])</div><div class="line">    v1 = tf.get_variable(&apos;v&apos;)</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line"></div><div class="line">def convolution(in_put, in_channel, out_channel):</div><div class="line">    with tf.variable_scope(name_or_scope=&apos;&apos;, reuse=tf.AUTO_REUSE):</div><div class="line">        weights = tf.get_variable(name=&quot;weights&quot;, shape=[2, 2, in_channel, out_channel],</div><div class="line">                                  initializer=tf.contrib.layers.xavier_initializer_conv2d())</div><div class="line">        output = tf.nn.conv2d(input=in_put, filter=weights, strides=[1, 1, 1, 1], padding=&quot;SAME&quot;)</div><div class="line">    return output</div><div class="line"></div><div class="line"></div><div class="line">def main():</div><div class="line">    with tf.Graph().as_default():</div><div class="line">        input_x = tf.placeholder(dtype=tf.float32, shape=[1, 4, 4, 1])</div><div class="line"></div><div class="line">        for _ in range(5):</div><div class="line">            output = convolution(input_x, 1, 1)</div><div class="line">            with tf.Session() as sess:</div><div class="line">                sess.run(tf.global_variables_initializer())</div><div class="line">                _output = sess.run([output], feed_dict=&#123;input_x: np.random.uniform(low=0, high=255, size=[1, 4, 4, 1])&#125;)</div><div class="line">                print(_output)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="reuse参数使用"><a href="#reuse参数使用" class="headerlink" title="reuse参数使用"></a>reuse参数使用</h2><ul>
<li><strong>当参数reuse=False，函数get_variable（）表示创建变量</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">with tf.variable_scope(&quot;foo&quot;, reuse=False):</div><div class="line">	v = tf.get_variable(&quot;v&quot;, [1], initializer=tf.constant_initializer(1.0))</div><div class="line">	v1 = tf.get_variable(&quot;v&quot;, [1])</div><div class="line"></div><div class="line"># 输出结果：</div><div class="line"># ValueError: Variable foo/v already exists, disallowed. </div><div class="line"># Did you mean to set reuse=True or reuse=tf.AUTO_REUSE in VarScope?</div></pre></td></tr></table></figure>
<ul>
<li><strong>当参数reuse=True，函数get_variable（）表示获取变量</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">with tf.variable_scope(&quot;foo&quot;):</div><div class="line">	v = tf.get_variable(&quot;v&quot;, [1], initializer=tf.constant_initializer(1.0))</div><div class="line"></div><div class="line">with tf.variable_scope(&quot;foo&quot;, reuse=True):</div><div class="line">	v1 = tf.get_variable(&quot;v&quot;, [1])</div><div class="line"></div><div class="line">print(v1 == v)</div><div class="line"></div><div class="line"># 输出结果：True</div></pre></td></tr></table></figure>
<p>在tf.variable_scope()函数中，设置reuse=True时，在其命名空间”foo”中执行函数get_variable()时，表示获取变量”v”。若在该命名空间中还没有该变量，则在获取时会报错，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import tensorflow as tf </div><div class="line"></div><div class="line">with tf.variable_scope(&quot;foo&quot;, reuse=True):</div><div class="line">    v1 = tf.get_variable(&quot;v&quot;,[1])</div><div class="line"></div><div class="line"># 输出结果：</div><div class="line"># ValueError: Variable foo/v does not exist, or was not created with tf.get_variable(). </div><div class="line"># Did you mean to set reuse=tf.AUTO_REUSE in VarScope?</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://www.zhihu.com/question/54513728/answer/181819324" target="_blank" rel="external">tensorflow里面name_scope, variable_scope等如何理解？</a><br>[2]: <a href="https://blog.csdn.net/qq_35203425/article/details/82469348" target="_blank" rel="external">tf.AUTO_REUSE作用</a><br>[3]: <a href="https://blog.csdn.net/johnboat/article/details/84846628" target="_blank" rel="external">TensorFlow中变量管理reuse参数的使用</a> </p>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu环境MYSQL乱码问题修复</title>
    <url>/2018/12/09/Ubuntu%E7%8E%AF%E5%A2%83MYSQL%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<blockquote>
<p>首先声明笔者使用的服务器是Ubuntu16.04，数据库安装的是Mysql 5.7。初始的mysql默认字符集是latin1，如果向数据库中插入中文就会出现乱码，下面我们通过修改配置文件的方式修改mysql的默认编码。</p>
</blockquote>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><h2 id="修改-mysqld"><a href="#修改-mysqld" class="headerlink" title="修改[mysqld]"></a>修改[mysqld]</h2><p>找到文件/etc/mysql/mysql.conf.d/mysqld.cnf 中的[mysqld]并在其最后面追加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">character-set-server=utf8</div></pre></td></tr></table></figure>
<h2 id="修改-mysql"><a href="#修改-mysql" class="headerlink" title="修改[mysql]"></a>修改[mysql]</h2><p>找到文件/etc/mysql/conf.d/mysql.cnf中的[mysql]并在其最后面追加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure>
<h2 id="修改-client"><a href="#修改-client" class="headerlink" title="修改[client]"></a>修改[client]</h2><p>找到文件/etc/mysql/debian.cnf中的[client]并在其最后面追加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure>
<h1 id="重启MYSQL"><a href="#重启MYSQL" class="headerlink" title="重启MYSQL"></a>重启MYSQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">service mysql restart</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="查看字符集"><a href="#查看字符集" class="headerlink" title="查看字符集"></a>查看字符集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql -u root -p </div><div class="line">show variables like &apos;%character%&apos;;</div></pre></td></tr></table></figure>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>笔者在做完如上配置之后发现通过navicat连接mysql查看内容还是出现乱码，但是其他地方返回的数据均能够正常显示。出现上述情况可以按照如下步骤进行操作：</p>
<ol>
<li><p>右键—&gt;编辑连接—&gt;高级</p>
</li>
<li><p>将编码方式设置为自动</p>
</li>
</ol>
]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>LAMP环境搭建以及MYSQL远程访问配置</title>
    <url>/2018/12/04/LAMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AMYSQL%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>首先声明笔者使用的服务器是Ubuntu16.04。下面正式进入配置教程：</p>
<h1 id="LAMP环境搭建"><a href="#LAMP环境搭建" class="headerlink" title="LAMP环境搭建"></a>LAMP环境搭建</h1><h2 id="安装Apache2"><a href="#安装Apache2" class="headerlink" title="安装Apache2"></a>安装Apache2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get  install apache2</div></pre></td></tr></table></figure>
<p>检查apache2是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apache2 –v</div></pre></td></tr></table></figure>
<h2 id="安装PHP7"><a href="#安装PHP7" class="headerlink" title="安装PHP7"></a>安装PHP7</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get install php</div></pre></td></tr></table></figure>
<p>查看PHP版本并检查PHP是否按照成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">php –v</div></pre></td></tr></table></figure>
<h2 id="安装MYSQL"><a href="#安装MYSQL" class="headerlink" title="安装MYSQL"></a>安装MYSQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get install mysql-server</div><div class="line">sudo apt-get install mysql-client</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装配置组件"><a href="#安装配置组件" class="headerlink" title="安装配置组件"></a>安装配置组件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">sudo apt-get <span class="keyword">install</span> libapache2-<span class="keyword">mod</span>-php</div><div class="line"></div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libapache2-<span class="keyword">mod</span>-auth-mysql  # 现在这个组件作者以及放弃维护了，因为新版apache以及包含这个模块所实现的功能，可以不用安装</div><div class="line"></div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> php-mysql</div><div class="line"></div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> php-gd  # php图形库</div></pre></td></tr></table></figure>
<h2 id="启用mod-rewrite模块"><a href="#启用mod-rewrite模块" class="headerlink" title="启用mod_rewrite模块"></a>启用mod_rewrite模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">service apache2 restart</div></pre></td></tr></table></figure>
<h2 id="重启Apache2和MYSQL"><a href="#重启Apache2和MYSQL" class="headerlink" title="重启Apache2和MYSQL"></a>重启Apache2和MYSQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo service apache2 restart</div><div class="line">sudo service mysql restart</div></pre></td></tr></table></figure>
<h2 id="测试PHP"><a href="#测试PHP" class="headerlink" title="测试PHP"></a>测试PHP</h2><p>创建一个php文件来测试环境是否安装成功，PHP文件（文件名为test.php）内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    echo phpinfo();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>通过IP/test.php查看是否连接成功。</p>
<h2 id="端口允许"><a href="#端口允许" class="headerlink" title="端口允许"></a>端口允许</h2><p>通过上述步骤我们可能还是不能通过IP地址访问服务器，那是因为阿里云默认是没有开放80端口的，我们需要前往阿里云的控制台将80端口添加到安全组。</p>
<h1 id="MYSQL远程访问配置"><a href="#MYSQL远程访问配置" class="headerlink" title="MYSQL远程访问配置"></a>MYSQL远程访问配置</h1><h2 id="修改MYSQL配置"><a href="#修改MYSQL配置" class="headerlink" title="修改MYSQL配置"></a>修改MYSQL配置</h2><p>我们通过修改MYSQL的配置文件运行允许所有主机访问服务器上的MYSQL数据库：</p>
<p>使用vim编辑mysql的配置文件/etc/mysql/mysql.conf.d/mysqld.cnf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</div></pre></td></tr></table></figure>
<p>然后修改文件中的bind-address的值为0.0.0.0</p>
<h2 id="修改MYSQL用户访问权限"><a href="#修改MYSQL用户访问权限" class="headerlink" title="修改MYSQL用户访问权限"></a>修改MYSQL用户访问权限</h2><p>首先进入MYSQL数据库，使用mysql数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">use mysql;</div></pre></td></tr></table></figure>
<p>然后:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">update user set host = &apos;%&apos; where user = &apos;root&apos;;</div></pre></td></tr></table></figure>
<p>查看MYSQL用户权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select host, user from user;</div></pre></td></tr></table></figure>
<p>have fun!</p>
]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>lamp</tag>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP接口返回500错误状态码解决方法</title>
    <url>/2018/11/17/PHP%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E500%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在用PHP写用户登录接口，但是将PHP代码部署到生产环境却发生了错误，用浏览器访问接口产生错误状态码500如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTTP ERROR 500</div></pre></td></tr></table></figure>
<p>这个错误是由于PHP代码存在错误引起的，但是默认PHP是关闭错误提示的。如果想要知道代码的错误必须先打开PHP的错误显示功能。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先声明笔者使用的生产环境是Ubuntu 16.04。</p>
<p>第一步：先找到PHP的配置文件php.ini文件所在位置，这里笔者的Ubuntu中的php7的php.ini存在于路径/etc/php/7.0/apache2/下面，我们只需要使用vi/vim从上述路径下打开php.ini文件；</p>
<p>第二步：查找并修改php.ini文件中的display_errors和display_startup_errors中的值为On即可；</p>
<p>修改后的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#修改你的php.ini文件</div><div class="line">display_errors = On</div><div class="line">display_startup_errors = On</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>第三步：重启php-fpm。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/etc/init.d/php7.0-fpm restart</div></pre></td></tr></table></figure>
<p>更多版本php操作详见如下<a href="https://serverfault.com/questions/189940/how-do-you-restart-php-fpm" target="_blank" rel="external">链接</a>，另外还有appache2相关操作见如下<a href="https://www.cnblogs.com/supe/p/8010612.html" target="_blank" rel="external">链接</a>。</p>
<p>到此为止就可以查看到错误信息了。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python大数据量计数</title>
    <url>/2018/09/10/Python%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>和上一篇文章一样，这篇文章也是我在数学建模中碰到的，如果只是普通数据量的计数问题那么我们不妨使用counter，但是如果数据量达到一定规模，那么我们不得不考虑其他算法来解决问题了。我们这里使用hyperloglog算法来实现大数据量计数问题，这种算法是一种基于统计的计数算法，算法并不一定准确，但是足够快，如果读者将速度放在第一位那么不妨试试这种算法，而且hyperloglog算法准确率逼近100%，试问1000001和100000又有多大的差距呢，所以这种算法是有一定实用性的。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>当然作为胶水语言的Python，我们当然不必重复造轮子，这里我们可以直接使用python的bounter库来实现hyperloglog算法计数。</p>
<p>安装方法：<code>pip install bounter</code></p>
<p>这里给出bounter在github上的官方教材使用的代码：</p>
<p><strong>示例一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from bounter import bounter</div><div class="line"></div><div class="line">counts = bounter(size_mb=1024)  # use at most 1 GB of RAM</div><div class="line">counts.update([u&apos;a&apos;, &apos;few&apos;, u&apos;words&apos;, u&apos;a&apos;, u&apos;few&apos;, u&apos;times&apos;])  # count item frequencies</div><div class="line"></div><div class="line">print(counts[u&apos;few&apos;])  # query the counts</div><div class="line">2</div></pre></td></tr></table></figure>
<p><strong>示例二</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from bounter import bounter</div><div class="line"></div><div class="line">counts = bounter(size_mb=200)  # default version, unless you specify need_items or need_counts</div><div class="line">counts.update([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;])</div><div class="line">print(counts.total(), counts.cardinality())  # total and cardinality still work</div><div class="line">(5L, 3)</div><div class="line">print(counts[&apos;a&apos;])  # individual item frequency still works</div><div class="line">2</div><div class="line"></div><div class="line">print(list(counts))  # iterator returns keys, just like Counter</div><div class="line">[u&apos;b&apos;, u&apos;a&apos;, u&apos;c&apos;]</div><div class="line">print(list(counts.iteritems()))  # supports iterating over key-count pairs, etc.</div><div class="line">[(u&apos;b&apos;, 2L), (u&apos;a&apos;, 2L), (u&apos;c&apos;, 1L)]</div></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现最近点对求解</title>
    <url>/2018/09/10/Python%E5%AE%9E%E7%8E%B0%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>数学建模中遇到求最近点对的问题，按理说我们使用朴素法进行暴力求解答案也是可行的，但是由于数据过于庞大，我们最初使用朴素法在计算机上跑了6个小时都没有得到问题的解，最终只得作罢。后来我们利用分治法解决了最近点对问题，具体思路参看<a href="http://apir8181.github.io/algorithm/2014/10/02/closest_pair.html" target="_blank" rel="external">这里</a>。</p>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>分治法解决最近点对问题的算法过程读者可以参见上文给出的参考博客。分治法的思想就是先将问题分解成一个个小的问题，最后将小问题的答案合并得到问题的解。这其中关键步骤是分解与合并，具体实现方法是使用递归，核心思想是空间换时间。</p>
<a id="more"></a>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>上面给出的教程中是使用C++实现的，我这里给出Python实现。</p>
<p>由于我这里具体的问题是给出经纬度找出最近点对，所以我采用的距离为改进的球面余弦距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">from collections import Counter</div><div class="line">from math import sqrt,acos, sin, cos, radians</div><div class="line"></div><div class="line">def nearest_dot(s):</div><div class="line">    mid = int(len(s)/2)</div><div class="line">    left = s[0:mid]</div><div class="line">    right = s[mid:]</div><div class="line">    mid_x = (left[-1][0]+right[0][0])/2.0</div><div class="line"></div><div class="line">    if len(left) &gt; 2:   lmin = nearest_dot(left)    #左侧部分最近点对</div><div class="line">    else:   lmin = left</div><div class="line">    if len(right) &gt; 2:   rmin = nearest_dot(right)   #右侧部分最近点对</div><div class="line">    else:   rmin = right</div><div class="line"></div><div class="line">    if len(lmin) &gt;1: dis_l = get_distance(lmin)</div><div class="line">    else: dis_l = float(&quot;inf&quot;)</div><div class="line">    if len(rmin) &gt;1: dis_r = get_distance(rmin)</div><div class="line">    else: dis_r = float(&quot;inf&quot;)</div><div class="line"></div><div class="line">    d = min(dis_l, dis_r)   #最近点对距离</div><div class="line"></div><div class="line">    mid_min=[]</div><div class="line">    for i in left:</div><div class="line">        if mid_x-i[0]&lt;=d :   #如果左侧部分与中间线的距离&lt;=d</div><div class="line">            for j in right:</div><div class="line">                if abs(i[0]-j[0])&lt;=d and abs(i[1]-j[1])&lt;=d:     #如果右侧部分点在i点的(d,2d)之间</div><div class="line">                    if get_distance((i,j))&lt;=d: mid_min.append([i,j])   #ij两点的间距若小于d则加入队列</div><div class="line">    if mid_min:</div><div class="line">        dic=[]</div><div class="line">        for i in mid_min:</div><div class="line">            dic.append(&#123;get_distance(i):i&#125;)</div><div class="line">        dic.sort(key=lambda x: x.keys())</div><div class="line">        return list(dic[0].values())[0]</div><div class="line">    elif dis_l&gt;dis_r:</div><div class="line">        return rmin</div><div class="line">    else:</div><div class="line">        return lmin</div><div class="line">        </div><div class="line"># 求点对的距离</div><div class="line">def get_distance(m):</div><div class="line">    dx = m[0][1] - m[1][1]  # 经度差值</div><div class="line">    dy = m[0][0] - m[1][0]  # 纬度差值</div><div class="line">    # b = (lat1 + lat2) / 2.0  # 平均纬度</div><div class="line">    # Lx = (a[3] * b*b*b  + a[2]* b*b  + a[1] * b + a[0]) * radians(dx) * 6367000.0  # 东西距离(单位：米)</div><div class="line">    Lx = cos(dx) * radians(dx) * 6367000.0  # 东西距离(单位：米)</div><div class="line">    Ly = 6367000.0 * radians(dy)  # 南北距离</div><div class="line">    return sqrt(Lx * Lx + Ly * Ly)</div><div class="line"></div><div class="line">def divide_conquer(s):</div><div class="line">    s.sort()</div><div class="line">    nearest_dots = nearest_dot(s)</div><div class="line">    return nearest_dots</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现argsort排序返回索引值</title>
    <url>/2018/09/05/python%E5%AE%9E%E7%8E%B0argsort%E6%8E%92%E5%BA%8F%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>插曲是这样的，之前一直在给别人写外包程序，在程序中我使用到了numpy库中的argsort排序方法，这个排序方法十分方便，对可迭代对象进行排序并返回原顺序的索引值。由于程序要传给客户，所以我将代码封装成了exe可执行程序。之前封装出来的程序最多也就40来兆，可是自从我将开发环境切换到anaconda后，封装出来的程序高达200多兆，简直吓死我了。今天客户再次需要这个程序，于是我决定抛弃numpy库，自己实现argsort算法。</p>
</blockquote>
<h1 id="numpy实现"><a href="#numpy实现" class="headerlink" title="numpy实现"></a>numpy实现</h1><p>首先来看看numpy库中argsort的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">argsort(a, axis=-1, kind=&apos;quicksort&apos;, order=None)</div></pre></td></tr></table></figure>
<p>第一个参数是需要排序的可迭代对象，第二个参数是排序的维度，第三个参数是排序的算法，常见的有快排（quicksort）、堆排序（heapsort）以及归并排序（mergesort）。第四个参数是排序的次序。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import numpy as np</div><div class="line"></div><div class="line">li = [1.5, 3, 15, 21, 7, 31, 5]</div><div class="line"></div><div class="line">indies = np.argsort(li, kind=&apos;heapsort&apos;)</div><div class="line">print(indies)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[0 1 6 4 2 3 5]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="原生python实现"><a href="#原生python实现" class="headerlink" title="原生python实现"></a>原生python实现</h1><p>其实原生python的实现主要是借用python内置函数sorted，但是sorted函数返回的结果是排序的最终结果而不是排序之前的索引值序列。但是我们可以利用sorted函数对字典排序的能力，将列表转换成字典就可以了。列表转字典的方法是先将列表通过enumerate函数转换成枚举型，然后在通过dict函数转换成字典。这样传入的列表就变为一个键为索引值为原值的一个字典了。这样我们再使用sorted函数对字典排序，再返回字典的键就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def argsort(X):</div><div class="line">    d = dict(enumerate(X))</div><div class="line">    r = dict(sorted(d.items(), key=lambda x:x[1]))</div><div class="line">    return list(r.keys())</div><div class="line"></div><div class="line">li = [1.5, 3, 15, 21, 7, 31, 5]</div><div class="line"></div><div class="line">indies = argsort(li)</div><div class="line">print(indies)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[0, 1, 6, 4, 2, 3, 5]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊综合评价法原理及实现</title>
    <url>/2018/09/02/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="模糊综合评价法原理"><a href="#模糊综合评价法原理" class="headerlink" title="模糊综合评价法原理"></a>模糊综合评价法原理</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>模糊综合评价法是一种基于模糊数学的综合评价方法。该综合评价法根据模糊数学的<strong>隶属度理论</strong>把定性评价转化为定量评价，即用模糊数学对受到多种因素制约的事物或对象做出一个总体的评价。它具有结果清晰，系统性强的特点，能较好地解决模糊的、难以量化的问题，适合各种非确定性问题的解决。</p>
<h2 id="隶属度"><a href="#隶属度" class="headerlink" title="隶属度"></a>隶属度</h2><p>隶属函数，也称为归属函数或模糊元函数，是模糊集合中会用到的函数，是一般集合中指示函数的一般化。指示函数可以<strong>说明一个集合中的元素是否属于特定子集合</strong>。一元素的指示函数的值可能是0或是1，而元素的<strong>隶属函数会是0到1之间的数值</strong>，表示元素属于某模糊集合的“真实程度”（degree of truth）即隶属度。</p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>设评判对象为P: 其因素集 $ U={ u_1, u_2, \cdots , u_n } $  ,评判等级集 $ V={ v_1, v_2, \cdots ,v_m } $ 。对U中每一因素根据评判集中的等级指标进行模糊评判，得到评判矩阵：</p>
<script type="math/tex; mode=display">
R=\begin{bmatrix}
r{11},r{12},\cdots,r{1m} \\ 
r{21},r{22},\cdots,r{2m} \\ 
r{n1},r{n2},\cdots,r_{nm}
\end{bmatrix}</script><p>通常为了避免量纲的影响，我们还要进行去量纲操作。</p>
<p>其中，$r<em>{ij}$表示$u_i$关于$v_j$的隶属度。(U,V,R) 则构成了一个模糊综合评判模型。确定各因素重要性指标（也称权数）后，记为$A={ a_1,a_2, \cdots,a_n }$,满足$\sum</em>{i=1}^na_i=1$，合成得</p>
<script type="math/tex; mode=display">
\overline B = A\cdot R=\left(\overline {b_1}, \overline {b_2}, \cdots ,\overline {b_m} \right)</script><p>经归一化后，得 $ B= { b_i, b_2, \cdots, b_m } $ ,于是可确定对象P的评判等级。</p>
<p>如果想得到综合得分，那么我们还可以对B进一步打分，即以同样的方式设置权数，对B进行综合评定。</p>
<p>对问题进行模糊综合分析之后我们通常还要考察该模型的置信度。</p>
<a id="more"></a>
<p><strong>权数的确定：</strong></p>
<p>权数可以通过数学方法来确定，也可以由具有权威性的专家及具有代表性的人按因素的重要程度来商定。不过现在通用的做法是凭经验给出权重。</p>
<p><strong>合成算法：</strong></p>
<p>合成算法即加权的方式，常见算法有：</p>
<ul>
<li>主因素决定型</li>
</ul>
<script type="math/tex; mode=display">
b_i=\max \left \{ \min \left \{ a_1,r_{1i} \right\},\min \left \{ a_2,r_{2i} \right\} ,\cdots,\min \left \{ a_n,r_{ni} \right\}\right\}</script><ul>
<li>主因素突出型</li>
</ul>
<script type="math/tex; mode=display">
b_i=\max \left \{ a_1\times r_{1i}, a_2\times r_{2i} ,\cdots,a_n\times r_{ni}\right\}</script><ul>
<li>加权平均型</li>
</ul>
<script type="math/tex; mode=display">
b_i=a_1\times r_{1i} + a_2\times r_{2i} +\cdots+a_n\times r_{ni}</script><p>加权平均型算法常用在因素集很多的情形，它可以避免信息丢失；主因素突出型算法常用在所统计的模糊矩阵中的数据相差很悬殊的情形，它可以防止特殊数据的干扰。 </p>
<h1 id="实例：教学质量评价"><a href="#实例：教学质量评价" class="headerlink" title="实例：教学质量评价"></a>实例：教学质量评价</h1><p>我们首先按照票数结果统计了25名学生对某位老师的教学质量评价表，统计结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">好（100）</th>
<th style="text-align:center">较好（85）</th>
<th style="text-align:center">一般（70）</th>
<th style="text-align:center">较差（55）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 教学计划及教学内容安排（0.10）</td>
<td style="text-align:center">9</td>
<td style="text-align:center">14</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>2. 教材及参考资料状况（0.10）</td>
<td style="text-align:center">3</td>
<td style="text-align:center">14</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>3. 教师教学态度及责任心（0.15）</td>
<td style="text-align:center">5</td>
<td style="text-align:center">15</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>4. 教师讲解能力（0.10）</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td>5. 课堂教学形式的多样化程度（0.10）</td>
<td style="text-align:center">2</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>6. 理论联系实际程度及教学案例使用情况（0.10）</td>
<td style="text-align:center">5</td>
<td style="text-align:center">14</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>7. 辅助教学环节及考核情况（0.10）</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">13</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>8. 教学改革与创新情况（0.10）</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8</td>
<td style="text-align:center">12</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>9. 从本课程学习中所获得的收益程度（0.15）</td>
<td style="text-align:center">5</td>
<td style="text-align:center">12</td>
<td style="text-align:center">6</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>由于我们最终要给每项指标打分，如果直接使用票数计算那么必然会导致结果收到参评人员数量的影响，即参评人数为1000和参评人数为25的结果截然不同，所以我们使用某项指标的某个等级票数的频率来代替票数来表示<strong>隶属度</strong>。各项因素的权数向量为：$[0.1, 0.1, 0.15, 0.10, 0.10, 0.10, 0.10,0.10, 0.15]$，评判等级的权数向量为:$[100, 85,70,55]$，其中两个权数向量之和为1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">好（100）</th>
<th style="text-align:center">较好（85）</th>
<th style="text-align:center">一般（70）</th>
<th style="text-align:center">较差（55）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 教学计划及教学内容安排（0.10）</td>
<td style="text-align:center">0.36</td>
<td style="text-align:center">0.56</td>
<td style="text-align:center">0.08</td>
<td style="text-align:center">0.00</td>
</tr>
<tr>
<td>2. 教材及参考资料状况（0.10）</td>
<td style="text-align:center">0.12</td>
<td style="text-align:center">0.56</td>
<td style="text-align:center">0.28</td>
<td style="text-align:center">0.04</td>
</tr>
<tr>
<td>3. 教师教学态度及责任心（0.15）</td>
<td style="text-align:center">0.20</td>
<td style="text-align:center">0.60</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.00</td>
</tr>
<tr>
<td>4. 教师讲解能力（0.10）</td>
<td style="text-align:center">0.04</td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.44</td>
<td style="text-align:center">0.12</td>
</tr>
<tr>
<td>5. 课堂教学形式的多样化程度（0.10）</td>
<td style="text-align:center">0.08</td>
<td style="text-align:center">0.44</td>
<td style="text-align:center">0.48</td>
<td style="text-align:center">0.00</td>
</tr>
<tr>
<td>6. 理论联系实际程度及教学案例使用情况（0.10）</td>
<td style="text-align:center">0.20</td>
<td style="text-align:center">0.56</td>
<td style="text-align:center">0.24</td>
<td style="text-align:center">0.00</td>
</tr>
<tr>
<td>7. 辅助教学环节及考核情况（0.10）</td>
<td style="text-align:center">0.16</td>
<td style="text-align:center">0.24</td>
<td style="text-align:center">0.52</td>
<td style="text-align:center">0.08</td>
</tr>
<tr>
<td>8. 教学改革与创新情况（0.10）</td>
<td style="text-align:center">0.12</td>
<td style="text-align:center">0.32</td>
<td style="text-align:center">0.48</td>
<td style="text-align:center">0.08</td>
</tr>
<tr>
<td>9. 从本课程学习中所获得的收益程度（0.15）</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.48</td>
<td style="text-align:center">0.24</td>
<td style="text-align:center">0.08</td>
</tr>
<tr>
<td><strong>综合隶属度</strong></td>
<td style="text-align:center">0.168</td>
<td style="text-align:center">0.47</td>
<td style="text-align:center">0.318</td>
<td style="text-align:center">0.044</td>
</tr>
</tbody>
</table>
</div>
<p>综合隶属度由各项因素的权数向量和相应列的评判等级向量经过合成算法（这里使用加权平均）后的结果，</p>
<p><strong>综合得分</strong>：0.168x100 + 0.47x85 + 0.318x70 + 0.044x55=81.43</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面代码中的fuzzy_method为主函数，fuzzy_comprehensive_evaluation为模糊综合评价法的主要逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function fuzzy_method</div><div class="line">    % 模糊综合评价模型主函数</div><div class="line">    A1=[0.1 0.2 0.3 0.4];</div><div class="line">    A2=[0.4 0.35 0.15 0.1];</div><div class="line">    R=[0.2 0.5 0.2 0.1;</div><div class="line">        0.7 0.2 0.1 0;</div><div class="line">        0 0.4 0.5 0.1;</div><div class="line">        0.2 0.3 0.5 0];</div><div class="line">    fuzzy_comprehensive_evaluation(1,A1,R)</div><div class="line">    fuzzy_comprehensive_evaluation(1,A2,R)</div><div class="line">end</div><div class="line"></div><div class="line">function B=fuzzy_comprehensive_evaluation(model,A,R) %模糊综合评判</div><div class="line">    % 参数model用于合成算法的确定，参数A为权数向量，参数R为隶属度矩阵。</div><div class="line">    B=[];</div><div class="line">    [m,s1]=size(A);</div><div class="line">    [s2,n]=size(R);</div><div class="line">    if(s1~=s2)</div><div class="line">         disp(&apos;A的列不等于R的行&apos;);</div><div class="line">    else</div><div class="line">        if(model==1)                 %主因素决定型</div><div class="line">            for(i=1:m)</div><div class="line">               for(j=1:n)</div><div class="line">                   B(i,j)=0;</div><div class="line">                   for(k=1:s1)</div><div class="line">                       x=0;</div><div class="line">                       if(A(i,k)&lt;R(k,j))</div><div class="line">                          x=A(i,k);</div><div class="line">                       else</div><div class="line">                          x=R(k,j);</div><div class="line">                       end</div><div class="line">                      if(B(i,j)&lt;x)</div><div class="line">                         B(i,j)=x;</div><div class="line">                      end</div><div class="line">                   end</div><div class="line">               end</div><div class="line">           end</div><div class="line">       elseif(model==2)               %主因素突出型</div><div class="line">           for(i=1:m)</div><div class="line">              for(j=1:n)</div><div class="line">                  B(i,j)=0;</div><div class="line">                  for(k=1:s1)</div><div class="line">                      x=A(i,k)*R(k,j);</div><div class="line">                      if(B(i,j)&lt;x)</div><div class="line">                         B(i,j)=x;</div><div class="line">                      end</div><div class="line">                  end</div><div class="line">              end</div><div class="line">           end</div><div class="line">       elseif(model==3)              %加权平均型</div><div class="line">              for(i=1:m)</div><div class="line">                 for(j=1:n)</div><div class="line">                    B(i,j)=0;</div><div class="line">                    for(k=1:s1)</div><div class="line">                        B(i,j)=B(i,j)+A(i,k)*R(k,j);</div><div class="line">                    end</div><div class="line">                  end</div><div class="line">               end</div><div class="line">        elseif(model==4)             %取小上界和型</div><div class="line">               for(i=1:m)</div><div class="line">                   for(j=1:n)</div><div class="line">                       B(i,j)=0;</div><div class="line">                       for(k=1:s1)</div><div class="line">                           x=0;</div><div class="line">                           x=min(A(i,k),R(k,j));</div><div class="line">                           B(i,j)=B(i,j)+x;</div><div class="line">                       end</div><div class="line">                           B(i,j)=min(B(i,j),1);</div><div class="line">                   end</div><div class="line">                end</div><div class="line">          elseif(model==5)            %均衡平均型</div><div class="line">                C=[];</div><div class="line">                C=sum(R);</div><div class="line">                for(j=1:n)</div><div class="line">                   for(i=1:s2)</div><div class="line">                       R(i,j)=R(i,j)/C(j);</div><div class="line">                   end</div><div class="line">                end</div><div class="line">                for(i=1:m)</div><div class="line">                    for(j=1:n)</div><div class="line">                        B(i,j)=0;</div><div class="line">                       for(k=1:s1)</div><div class="line">                           x=0;</div><div class="line">                           x=min(A(i,k),R(k,j));</div><div class="line">                           B(i,j)=B(i,j)+x;</div><div class="line">                       end</div><div class="line">                    end</div><div class="line">                end</div><div class="line">            else</div><div class="line">                disp(&apos;模型赋值不当&apos;);</div><div class="line">            end</div><div class="line">    end</div><div class="line">end</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>模糊综合评价法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记</title>
    <url>/2018/08/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h1><p>优化模型就是给定一个目标函数，然后在约束条件下求出该目标函数的最优值。</p>
<p>形如：</p>
<script type="math/tex; mode=display">
\min(或\max)\ z=f(x), x=(x_1,...)\\
s.t. g_i(x)\leq0,i=1,2,...</script><p>决策变量： x</p>
<p>目标函数： f(x)</p>
<p>约束条件： $ s.t. g_i(x)\leq0 $</p>
<p>优化问题三要素：</p>
<ul>
<li>决策变量</li>
<li>目标函数</li>
<li>约束条件</li>
</ul>
<p>数学规划：</p>
<ul>
<li>线性规划（Linear Programming，简称LP）</li>
<li>非线性规划(Nonlinear Programming，简称NLP)</li>
<li>整数规划</li>
</ul>
<a id="more"></a>
<h2 id="LINGO软件求解优化模型"><a href="#LINGO软件求解优化模型" class="headerlink" title="LINGO软件求解优化模型"></a>LINGO软件求解优化模型</h2><p>例题：</p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
\max \ S\\
\begin{cases}
    a_i x_i=S,i=1,2,... \\
    \sum^6_{i=1}x_i=5000, \\
    a_5x_6=5000.
\end{cases}
\end{array}</script><div class="table-container">
<table>
<thead>
<tr>
<th>存期年限</th>
<th>1年</th>
<th>2年</th>
<th>3年</th>
<th>4年</th>
<th>5年</th>
</tr>
</thead>
<tbody>
<tr>
<td>最有收益</td>
<td>1.018</td>
<td>1.0432</td>
<td>1.0776</td>
<td>1.09715968</td>
<td>1.144</td>
</tr>
</tbody>
</table>
</div>
<p>LINGO代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">!求解规划问题;</div><div class="line">model:</div><div class="line">min = S;</div><div class="line">1.018 * x1 = S;</div><div class="line">1.0432 * x2 = S;</div><div class="line">1.07776 * x3 = S;</div><div class="line">1.09715968 * x4 = S;</div><div class="line">1.144 * x5 = S;</div><div class="line">x1 + x2 + x3 + x4 + x5 + x6 = 5000;</div><div class="line">1.144 * x6 = 5000;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Global optimal solution found.</div><div class="line">Objective value:                              135.2227</div><div class="line">Infeasibilities:                              0.000000</div><div class="line">Total solver iterations:                             0</div><div class="line"></div><div class="line"></div><div class="line">                     Variable           Value        Reduced Cost</div><div class="line">                            S        135.2227            0.000000</div><div class="line">                           X1        132.8317            0.000000</div><div class="line">                           X2        129.6230            0.000000</div><div class="line">                           X3        125.4664            0.000000</div><div class="line">                           X4        123.2479            0.000000</div><div class="line">                           X5        118.2016            0.000000</div><div class="line">                           X6        4370.629            0.000000</div><div class="line"></div><div class="line">                          Row    Slack or Surplus      Dual Price</div><div class="line">                            1        135.2227           -1.000000</div><div class="line">                            2        0.000000           0.2110548</div><div class="line">                            3        0.000000           0.2059565</div><div class="line">                            4        0.000000           0.1993522</div><div class="line">                            5        0.000000           0.1958273</div><div class="line">                            6        0.000000           0.1878093</div><div class="line">                            7        0.000000          -0.2148538</div><div class="line">                            8        0.000000           0.1878093</div></pre></td></tr></table></figure>
<p>其中Objective value项即为所求目标值，下面的Variable即为在最优状态下各变量值。</p>
<p>关于LINGO教程网上有很多，在这里不再赘述。读者可以前往 <a href="https://www.jianshu.com/p/08be2f682323" target="_blank" rel="external">这里</a>查看。</p>
<h2 id="MATLAB软件求解优化模型"><a href="#MATLAB软件求解优化模型" class="headerlink" title="MATLAB软件求解优化模型"></a>MATLAB软件求解优化模型</h2><p>常用的优化功能函数：</p>
<ul>
<li>求解线性规划问题的主要函数是linprog。</li>
<li>求解二次规划问题的主要函数是quadprog。</li>
<li>求解无约束非线性规划问题的主要函数是fminbnd、fminunc和fminsearch。</li>
<li>求解约束非线性规划问题的主要函数是fgoalattain和fminimax。</li>
</ul>
<p>一般步骤：</p>
<ol>
<li>针对具体工程问题建立优化设计的数学模型</li>
<li>建立目标函数文件</li>
<li>建立约束函数文件</li>
<li>建立调用优化工具函数的命令文件</li>
<li>将优化设计的命令文件复制到MATLAB命令窗口中进行运算求解。</li>
</ol>
<h2 id="线性规划问题"><a href="#线性规划问题" class="headerlink" title="线性规划问题"></a>线性规划问题</h2><p><strong>数学模型形式：</strong></p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    \min f^TX \\
    s.t. AX\leq b~~~~(线性不等式约束条件) \\
    AeqX=beq~~~~（线性等式约束条件 \\
    lb \leq X \leq ub~~~~(边界约束条件)
\end{array}</script><p><strong>MATLAB中函数调用格式:</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><div class="line">[xopt, fopt]=linprog(f,  A,  b,  Aeq,  beq,  lb,  ub,  x0,  options)</div></pre></td></tr></table></figure>
<p>参数及返回值释义：</p>
<p>xopt: 最优解</p>
<p>fopt: 最优值</p>
<p>f: 目标函数各维变量系数向量</p>
<p>x0：初始点</p>
<p>options: 可选项</p>
<p>注： A,  b,  Aeq,  beq,  lb,  ub均和上述数学模型对应。</p>
<h2 id="二次规划问题"><a href="#二次规划问题" class="headerlink" title="二次规划问题"></a>二次规划问题</h2><p>数学模型形式：</p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    \min f(X)=\frac{1}{2}X^THX+C^TX \\
    s.t. AX\leq b
    AeqX=beq \\
    lb \leq X \leq ub
\end{array}</script><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[xopt, fopt]=quadprog(H,C, A, b, Aeq, beq, lb, ub, x0, options)</div></pre></td></tr></table></figure>
<p>参数及返回值释义：</p>
<p>xopt: 最优解</p>
<p>fopt: 最优值</p>
<p>H: 目标函数的海塞矩阵</p>
<p>C： 目标函数的一次项系数向量</p>
<p>其余同上。</p>
<p>示例：</p>
<p>求解约束优化问题</p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    f(X)=2X^2_1+2x^2_2+x^2_3-2x_1x_2+x_3\\
    s.t. g(X)=x_1+3x_2+2x_3\leq 6\\
    h(X)=2x_1-x_2+x_3=4\\
    x_1,x_2,x_3\geq 0
\end{array}</script><p>解：(1)将目标函数写成二次函数的形式$f(X)=\frac{1}{2}X^THX+C^TX$,其中：</p>
<p>$\begin{array}{lcl}<br>    X=\begin{bmatrix}<br>        x_1\<br>        x_2\<br>        x_3<br>    \end{bmatrix}<br>    H=\begin{bmatrix}<br>        4 &amp; -2 &amp; 0\<br>        -2 &amp; 4 &amp; 0\<br>        0 &amp; 0 &amp; 2<br>    \end{bmatrix}<br>    C=\begin{bmatrix}<br>        0\<br>        0\<br>        1<br>    \end{bmatrix}<br>\end{array}$</p>
<p>(2)编写求解二次规划的M文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">H=[4,-2,0;-2,4,0;0,0,2];</div><div class="line">C=[0,0,1];</div><div class="line">A=[1,3,2];</div><div class="line">b=[6];</div><div class="line">Aeq=[2,-1,1];</div><div class="line">beq=[4];</div><div class="line">lb=zeros(3,1);</div><div class="line">[xopt,fopt]=quadprig(H,C,A,b,Aeq,beq,lb)</div></pre></td></tr></table></figure>
<h2 id="其他规划问题"><a href="#其他规划问题" class="headerlink" title="其他规划问题"></a>其他规划问题</h2><p>其他规划问题的MATLAB函数使用方法和前面两个类似，这里不再赘述，具体使用方法读者可以查阅相关资料。</p>
<h1 id="微分方程及数值解"><a href="#微分方程及数值解" class="headerlink" title="微分方程及数值解"></a>微分方程及数值解</h1><p>数学建模中的微分方程模型，其实就是高等数学中的微积分知识在建模中的应用。常见的微分方程模型有人口模型和种群数量模型。</p>
<h2 id="实例-温度冷却"><a href="#实例-温度冷却" class="headerlink" title="实例 温度冷却"></a>实例 温度冷却</h2><p>由物理学知道,物体冷却的速度与当时的物体温度和周围环境温度之差成正比.今 100℃的沸水注入杯里,放在室温为 20℃的环境冷却,5min 后测得水温为 60℃.求水温 u 与时间 t 的函数关系.</p>
<ol>
<li>问题分析及模型的建立<br>设比例系数为k(k&gt;0),根据题意可得微分方程</li>
</ol>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    \frac{du}{dt}=-k(u-20)\\
    u|_{t=0}=100,u|_{t=5}=60
\end{array}</script><ol>
<li><p>模型的求解</p>
<p>此为简单的一阶可分离变量微分方程,可得解析解$u=20+80(0.5)^{\frac{t}{5}}$.</p>
</li>
</ol>
<p>使用MATLAB求解微分方程<strong>解析解</strong>(通解或特解)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dsolve(&apos;Du+k*(u-20)=0&apos;,&apos;u(0)=100&apos;,&apos;t&apos;)</div><div class="line">%dsolve 为求常微分方程的符号解函数</div></pre></td></tr></table></figure>
<p>运算结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">u =20+80*exp(-k*t)</div></pre></td></tr></table></figure>
<p>使用MATLAB求解微分方程<strong>数值解</strong>：</p>
<p>由给定条件$u|_{t=5}=60$,可得$k=\frac{\ln 2}{5}$,即$u=20+80(0.5)^\frac{t}{5}$.</p>
<p>MATLAB代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f=inline(&apos;-0.2*log(2)*(u-20)&apos;,&apos;t&apos;,&apos;u&apos;);</div><div class="line">[t,u]=ode45(f,[0,100],100);</div><div class="line">%ode45 为龙格库塔法求微分方程的数值解</div><div class="line">plot(t,u)</div><div class="line">%绘制 0 到 100 分钟的温度随时间变化的图形</div></pre></td></tr></table></figure>
<h2 id="MATLAB求解的函数微分方程-组"><a href="#MATLAB求解的函数微分方程-组" class="headerlink" title="MATLAB求解的函数微分方程(组)"></a>MATLAB求解的函数微分方程(组)</h2><p>那些不可以用积分方法求解的微分方程初值问题，可以用 MATLAB 的函数，如<strong>二三阶龙格-库塔法ode23</strong> 或<strong>四五阶龙格-库塔法 ode45</strong> 命令来求其数值解．<br>对于微分方程(组)的初值问题</p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    x(t)=f(t,x),x=(x_1,...,x_n)^T,f=(f_1,...,f_n)^T\\
    x(t_0)=x_0, x_0(x_{01},...,x_{0n})^T
\end{array}</script><p>可用下面的 MATLAB 命令实现计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[t,x]= =ode23(odefun ，ts ，x0 ，options)</div><div class="line">[t,x]= =ode45(odefun ，ts ，x0 ，options)</div></pre></td></tr></table></figure>
<p>这里 ode23 用的是 3 级 2 阶的龙格-库塔法公式，ode45 用的是 5 级 4 阶的龙格-库塔公式．输入参数 odefun 是待解方程写成的函数 M 文件或inline 格式的函数$f(t,x)$。</p>
<p> ts=[t0，t1，…，tf]，则输出为在指定时刻 t0，t1，…，tf 的函数值．如果输入 t0∶k∶tf，则输出为在[t0，tf]内以 k 为间隔的等分点处的函数值。</p>
<p>x0 为函数初值( n 维向量)。</p>
<p>options 可用于设定误差限（options 默认时设定相对误差${10}^{-3}$绝对误差${10}^{-6}$)，命令为：<br><code>options=odeset(‘reltol’，rt，‘abstol’，at)</code><br>这里 rt，at 分别为设定的相对误差和绝对误差。<br>命令的输出 t 为由输入指定的 ts，x 为相应的函数值( n维向量)。</p>
<h2 id="其他MATLAB函数"><a href="#其他MATLAB函数" class="headerlink" title="其他MATLAB函数"></a>其他MATLAB函数</h2><p>MATLAB中还有诸如求解偏微分方程的函数，读者可以自行查询相关资料。</p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>由于机器学习内容很多这里我只将常用学习算法进行归类。机器学习分为监督学习和无监督学习。其中监督学习又分为分类、集成学习、降维。</p>
<p>分类：</p>
<ul>
<li>K最近邻</li>
<li>决策树</li>
<li>贝叶斯分类器</li>
<li>逻辑回归</li>
<li>支持向量机</li>
</ul>
<p>集成学习：</p>
<ul>
<li>bagging：随机森林</li>
<li>boosting：AdaBoost、GBDT、XGBoost（工业级）</li>
</ul>
<p>无监督学习：</p>
<ul>
<li>K-Means</li>
<li>DBSCAN（基于密度的聚类）</li>
</ul>
<h1 id="概率统计模型"><a href="#概率统计模型" class="headerlink" title="概率统计模型"></a>概率统计模型</h1><script type="math/tex; mode=display">
\begin{array}{lcl}
    聚类~~\begin{cases}
    K-Means聚类（快速聚类）\\
    分层聚类（系统聚类）hierarchical\ cluster
    \end{cases}\\
    判别分析~~\begin{cases}
    根据距离判别\\
    fisher判别法\\
    逐步判别法（选择变量）
    \end{cases}\\
    时间序列分析~~\begin{cases}
    指数平滑\\
    Box-Jenkins方法
    \end{cases}
\end{array}</script><p>注：聚类分析对类及类的数量是未知的，而判别分析是已知的。</p>
<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><p>常用评价模型：</p>
<ul>
<li><strong>层次分析法</strong>：定性与定量相结合的多准则决策</li>
<li>灰色综合评价法：灰色关联度分析</li>
<li>模糊综合评价法： 根据模糊数学的隶属度评价</li>
<li>BP神经网络综合评价法</li>
<li>数据包络（DEA）： 是一个对多投入/多产出的多决策单元的效率评价方法，广泛使用于业绩评价</li>
</ul>
<p>综合评价模型：</p>
<ul>
<li>线性加权综合法 $y=\sum^m_{j=1}w_ix_j$</li>
<li>非线性加权综合法 $y=\prod^m_{j=1}x_j^{w_j}$</li>
<li>逼近理想点（TOPSIS）方法</li>
<li>动态加权</li>
</ul>
<p>动态加权函数：</p>
<ul>
<li>分段变幂函数</li>
</ul>
<ul>
<li>偏大型正态分布函数</li>
</ul>
<ul>
<li>S型分布函数</li>
</ul>
<h1 id="智能计算方法"><a href="#智能计算方法" class="headerlink" title="智能计算方法"></a>智能计算方法</h1><ul>
<li>模拟退火算法（SA）：寻找全局最优思想<ol>
<li>自动转换: 满足条件自动转换到另外一种状态</li>
<li>概率转换： 当不满足条件时按照一定的概率转换到另外一种状态</li>
</ol>
</li>
<li>遗传算法（GA）： 1. 选择 2. 交叉 3. 变异</li>
<li>粒子群算法（PSO）：信息共享思想</li>
</ul>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>灰色关联分析模型及其改进</title>
    <url>/2018/08/28/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h1 id="灰色关联分析基本原理"><a href="#灰色关联分析基本原理" class="headerlink" title="灰色关联分析基本原理"></a>灰色关联分析基本原理</h1><p>对于两个系统之间的因素，其随时间或不同对象而变化的关联性大小的度量，称为关联度。而根据因素之间发展趋势的相似或相异程度作为衡量因素间关联程度的方法称为灰色关联分析方法。对于本题衡量客户接受的程度与哪些因素关联度更高，我们可以使用灰色关联分析来衡量购买价格、维护成本、车门数、人员携带能力、行李箱大小、汽车安全性能等调查项和汽车可接受性之间的关联程度。 </p>
<p>首先，我们定义数据矩阵的最后一列l为标准要素，其余各列为需要比较的要素，分别用x<sup>‘</sup><sub>l</sub>和x<sup>‘</sup><sub>i</sub>表示。 </p>
<p>第一步：数据标准化 </p>
<script type="math/tex; mode=display">
X_i^\prime=\frac{X_i-\min X_i}{\max X_i-\min X_i}=(x_i^\prime(1),x_i^\prime(2),x_i^\prime(3),x_i^\prime(4)...)</script><p>第二步：求差序列</p>
<script type="math/tex; mode=display">
\Delta_i(k)=|x_l^\prime-x_i^\prime|;i=1,2,3,4...</script><p>第三步：求两极差</p>
<script type="math/tex; mode=display">
M=\max_i \max_k \Delta_i(k) \\
m=\min_i \min_k \Delta_i(k)</script><p>第四步：计算关联系数</p>
<script type="math/tex; mode=display">
\gamma_{li}=\frac{m+\rho M}{\Delta_i(k)+\rho M},i=2,3,4...</script><p>第五步：求灰色关联度</p>
<script type="math/tex; mode=display">
\gamma_{ln}=\frac{1}{N}\sum^N_{k=1}\gamma_{ln}(k),i=1,2,3,4...</script><a id="more"></a>
<h1 id="灰色关联分析改进模型"><a href="#灰色关联分析改进模型" class="headerlink" title="灰色关联分析改进模型"></a>灰色关联分析改进模型</h1><p>灰色关联分析的核心是计算关联度，但是原始的关联度计算方法对各样本平等看待，即采用平权处理。但是由于各个特征对结果的影响程度是不同的，如果采用平权处理，必然会丧失数据中隐藏的潜在特征，所以本文中我们对各特征进行加权处理。此处我们采用基于距离分析法对灰色关联分析算法进行改进。</p>
<p>改进后的公式为:</p>
<script type="math/tex; mode=display">
\gamma_{ln}=\sum^N_{k=1}\alpha(k)\gamma_{ln}(k),i=1,2,3,4...</script><p>其中权重α的计算方法如下：</p>
<p>我们以最优要素和最劣要素为参考要素。计算各个要素与参考要素的距离，离最优要素点近并且离最劣样本远的样本为总体较好的要素。</p>
<p>设数据为m x n矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{11}      & \cdots & a_{1n}      \\
\vdots & \ddots & \vdots \\
a_{m1}      & \cdots & a_{mn}
\end{bmatrix}</script><p>第一步：确定最优要素和最劣要素</p>
<script type="math/tex; mode=display">
A^+=(a^+_1,a^+_2,...,a^+_n)^T \\
A^-=(a^-_1,a^-_2,...,a^-_n)^T</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{array}{lcl}
    a^+_l=\max(a_{1l},a_{2l},...,a_{ml})\\
    a^-_l=\max(a_{1l},a_{2l},...,a_{ml}), l=1,2,3,...n
\end{array}</script><p>第二步：计算各要素点到参考要素点的距离。这里采用欧式距离，</p>
<script type="math/tex; mode=display">
D^+_k=\sqrt{\sum^n_{l=1}{(a_{kl}-a^+_l)}^2}</script><p>第三步：综合正负向距离</p>
<script type="math/tex; mode=display">
S_k=\frac{D^-_k}{D^+_k},k=1,2,...,m.</script><p>通过上式对各要素的距离进行综合评价，即当要素与最优要素点之间的距离越小，与最劣要素点之间的距离越大，那么该要素得到的分数越高。</p>
<p>但是为了防止Sk的分子和分母出现零，我们将Sk的分子和分母同时加上一个偏置β（这里的β一般取1）。得到，</p>
<script type="math/tex; mode=display">
S_k=\frac{D^-_k+\beta}{D^+_k+\beta},k=1,2,...,m.</script><p>第四步：数据归一化</p>
<script type="math/tex; mode=display">
\alpha_k=\frac{S_k}{\sum^m_{k=1}S_k}</script><p>则</p>
<script type="math/tex; mode=display">
\alpha=(\alpha_1,\alpha_2,...,\alpha_m)^T</script><p>即为所有权重向量。</p>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>灰色关联分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow中矩阵乘法matmul和multiply详解</title>
    <url>/2018/04/09/tensorflow%E4%B8%AD%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95matmul%E5%92%8Cmultiply%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在机器学习或者神经网络编程过程中，我们的运算对象通常是矩阵，而常用的矩阵操作就是点乘(dot product)和元素相乘(elementwise multiplication)。学过线性代数的读者肯定对点乘不会陌生，但是元素相乘就不一定知道了。其实elementwise multiplication就是将两个shape一样的矩阵按照对应元素相乘。 </p>
<h2 id="点乘matmul"><a href="#点乘matmul" class="headerlink" title="点乘matmul"></a>点乘matmul</h2><p>在tensorflow中的点乘使用matmul方法，其中matmul分两种情况。</p>
<p>首先我们通过一个例子来了解matmul方法的使用 ：<br>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="string">""" 2-D """</span></div><div class="line">print(<span class="string">"2-D:"</span>)</div><div class="line">sess = tf.Session()</div><div class="line">a = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], shape=[<span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 2-D tensor `a`</span></div><div class="line">print(<span class="string">"a = "</span>, sess.run(a))</div><div class="line">b = tf.constant([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], shape=[<span class="number">3</span>, <span class="number">2</span>])  <span class="comment"># 2-D tensor `b`</span></div><div class="line">print(<span class="string">"b = "</span>, sess.run(a))</div><div class="line">c = tf.matmul(a, b)</div><div class="line">print(<span class="string">"c = "</span>, sess.run(c))</div><div class="line"></div><div class="line"><span class="string">""" 3-D """</span></div><div class="line">print(<span class="string">"3-D:"</span>)</div><div class="line">a = tf.constant(np.arange(<span class="number">1</span>, <span class="number">13</span>, dtype=np.int32), shape=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 3-D tensor `a`</span></div><div class="line">print(<span class="string">"a = "</span>, sess.run(a))</div><div class="line">b = tf.constant(np.arange(<span class="number">13</span>, <span class="number">25</span>, dtype=np.int32), shape=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])  <span class="comment"># 3-D tensor `b`</span></div><div class="line">print(<span class="string">"b = "</span>, sess.run(a))</div><div class="line">c = tf.matmul(a, b)</div><div class="line">print(<span class="string">"c = "</span>, sess.run(c))</div><div class="line">sess.close()</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2-D:</div><div class="line">a =  [[1 2 3]</div><div class="line">      [4 5 6]]</div><div class="line">b =  [[1 2 3]</div><div class="line">      [4 5 6]]</div><div class="line">c =  [[ 58  64]</div><div class="line">      [139 154]]</div><div class="line"></div><div class="line">3-D:</div><div class="line">a =  [[[ 1  2  3]</div><div class="line">       [ 4  5  6]]</div><div class="line">      [[ 7  8  9]</div><div class="line">       [10 11 12]]]</div><div class="line">b =  [[[ 1  2  3]</div><div class="line">       [ 4  5  6]]</div><div class="line">      [[ 7  8  9]</div><div class="line">       [10 11 12]]]</div><div class="line">c =  [[[ 94 100]</div><div class="line">       [229 244]]</div><div class="line">      [[508 532]</div><div class="line">       [697 730]]]</div></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li>如果做点乘的两个矩阵的shape维度为2维，那么就按照一般矩阵点乘来计算。</li>
<li>如果点乘的两个矩阵的shape维度为3维，那么我们通常将第一维定义为batch_size，那么matmul方法就会逐个数据的将对应的维度按照第一种情况对两个矩阵做点乘。</li>
</ol>
<h2 id="元素相乘multiply"><a href="#元素相乘multiply" class="headerlink" title="元素相乘multiply"></a>元素相乘multiply</h2><p>两个矩阵中对应元素各自相乘</p>
<p>例如有矩阵 </p>
<pre><code>M1 = [
    a b c
    e f g
    h i j
]
</code></pre><p>和 </p>
<pre><code>M2 = [
    k l m
    n o p
    q r s
]
</code></pre><p>那么multiply(M1,M2)的结果为：</p>
<pre><code>[
    a*k b*l c*m
    e*n f*o g*p
    h*q i*r j*s
]
</code></pre><p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">a = tf.constant([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>], [<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>]])</div><div class="line">b = tf.constant([[<span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">13.</span>, <span class="number">14.</span>, <span class="number">15.</span>], [<span class="number">16.</span>, <span class="number">17.</span>, <span class="number">18.</span>]])</div><div class="line">c = tf.multiply(a, b)</div><div class="line">sess = tf.Session()</div><div class="line">print(sess.run(c))</div><div class="line">sess.close()</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[ 10.  22.  36.]</div><div class="line"> [ 52.  70.  90.]</div><div class="line"> [112. 136. 162.]]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫入门实践</title>
    <url>/2018/01/23/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>写这篇博客，一来是整理我最近一两个月的数据抓取经验，二来是帮助新手快速入门爬虫。听到爬虫这个词很多人可能会联想到谷歌，百度，必应等搜索引擎，它们拥有强大的数据检索能力，为我们查找资料提供了极大的帮助。这些搜索引擎之所以强大就是因为它们有一个强大的数据抓取系统。下面我们从0到1逐层展开讲解。</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>其实爬虫很简单，归结起来就是下面两个步骤： </p>
<ol>
<li>获取网页源代码</li>
<li>解析源代码获取需要的信息</li>
</ol>
<h2 id="获取网页源代码"><a href="#获取网页源代码" class="headerlink" title="获取网页源代码"></a>获取网页源代码</h2><p>在Python3中，获取网页源代码通常有两种方式：第一种是通过Python3自带的urllib库中的request.urlopen函数来请求网页源代码；第二种方式也是最常使用的方式就是使用requests库来实现网页的抓取。 </p>
<h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>首先我先来简单的介绍一下urllib库请求网页的方法： </p>
<pre><code>from urllib.request import urlopen
response = urlopen(&#39;https://pixabay.com/en/&#39;) #抓取全球著名免费矢量图网站pixabay
html = response.read()
</code></pre><h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3><p>下面开始介绍本教程获取网页源代码主要使用的工具：requests<br>requests的使用很简单和urllib类似： </p>
<pre><code>import requests
response = requests.get(&#39;https://pixabay.com/en/&#39;) #注意一定要加上url前面的安全协议https或者http不然系统会报错。
response.encoding = &#39;utf-8&#39; #设置网页的源代码编码格式为utf-8，你可以根据具体情况设置诸如gbk（国标）等编码格式。
html = response.text #获取源代码
</code></pre><a id="more"></a>
<h2 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h2><p>关于HTML我简要的说明一下：对于整个网页来说，它是使用html标记语言编写的，所以网页中的每一个元素都是一个节点，其中html标签用于包裹整个网页，head标签用于一些不需要可视化的代码编写其中包括网页的标题，引用的css文件和js文件等。而网站的主体被body标签包裹。body标签中有图层标签div（主要的标签）、img标签（图片标签）等。而每个标签都有一些属性比如class(类)、id(编号)等。其中id在整个网页中是唯一指定的，而class属性并不唯一。我们可以通过标签的层次关系以及这些标签的属性来定位我们需要抓取的数据。学习网络爬虫需要掌握一定的网页知识，如果读者欠缺这方面的知识可以前往<a href="http://www.runoob.com/" target="_blank" rel="external">菜鸟教程</a>学习有关html以及css有关的知识。 </p>
<p>解析HTML或者XML的工具或框架有很多，最常用的有: </p>
<ol>
<li>BeautifulSoup：使用正则表达式编写的html解析库</li>
<li>lxml：通过xml的节点查找信息的网页解析库（速度很快）</li>
<li>scrapy：集成爬虫框架</li>
<li>pyquery：Python中对jquery的实现，对于熟悉前端的人来说非常容易上手。</li>
</ol>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>BeautifulSoup有多种使用方法，对于查找元素可以使用find_all方法，但是笔者习惯使用select方法（css选择器语法）搜索文档。关于css选择器如果读者对前端足够熟悉的话应该能够轻松上手。经常使用到的标签包括div、span、ul、li、img、a等。我们使用点（.）表示标签的class属性，使用井（#）表示标签的id属性。在使用select方法的时候可以通过他们定位标签数据的位置。关于BeautifulSoup的具体使用方法，读者可以前往<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="external">官方文档</a>学习。</p>
<p>这里我们以抓取pixabay网站首页图片的url为例： </p>
<p>对于爬虫我建议大家使用chrome浏览器的控制台对页面进行分析（F12调出控制台）。 打开控制台后，选中Elements选项卡我们可以查看网页源代码，通过对网页的分析我们会发现图片的url为img标签的src属性，而img标签的父标签为a,a标签的父标签为div标签，div的父标签为带有class属性为flex_grid和credits的div标签，而该标签的父标签是id属性为gallery的标签。由于id属性是唯一的我们可以以该标签为源点，查找目标标签。</p>
<pre><code>import requests
from bs4 import BeautifulSoup
response = requests.get(&#39;https://pixabay.com/en/&#39;) #请求pixabay网站
response.encoding = &#39;utf-8&#39; #设置utf-8编码
html = response.text #网页源代码
soup = BeautifulSoup(html, &#39;lxml&#39;) #使用BeautifulSoup解析网页
imgs = soup.select(&#39;#gallery &gt; div.flex_grid.credits &gt; div &gt; a &gt; img&#39;) #使用css选择器定位链接，返回结果为包含所有图片标签的列表
for img in imgs:
    print(img[&#39;src&#39;]) #打印图片标签的src属性
</code></pre><p>运行结果： </p>
<pre><code>https://cdn.pixabay.com/photo/2018/06/23/16/22/romanesco-3493007__340.jpg
https://cdn.pixabay.com/photo/2018/07/08/14/16/cat-3523992__340.jpg
https://cdn.pixabay.com/photo/2018/05/30/15/31/rustic-3441673__340.jpg
https://cdn.pixabay.com/photo/2016/06/29/09/28/golf-1486354__340.jpg
https://cdn.pixabay.com/photo/2017/11/10/08/10/son-2935723__340.jpg
https://cdn.pixabay.com/photo/2018/07/06/13/30/statue-3520416__340.jpg
https://cdn.pixabay.com/photo/2018/07/08/15/32/dahlia-3524115__340.jpg
https://cdn.pixabay.com/photo/2018/05/07/22/08/sydney-opera-house-3381786__340.jpg
https://cdn.pixabay.com/photo/2018/07/05/23/31/ivy-3519431__340.jpg
https://cdn.pixabay.com/photo/2017/06/05/14/55/glass-2374311__340.jpg
https://cdn.pixabay.com/photo/2018/04/12/11/44/apple-3313225__340.jpg
https://cdn.pixabay.com/photo/2017/09/22/09/48/desert-2774945__340.jpg
https://cdn.pixabay.com/photo/2017/07/12/22/51/couple-2498660__340.jpg
https://cdn.pixabay.com/photo/2016/06/20/03/15/pier-1467984__340.jpg
https://cdn.pixabay.com/photo/2018/01/29/10/40/shower-of-sparks-3115784__340.jpg
https://cdn.pixabay.com/photo/2017/09/06/20/35/massage-2722936__340.jpg
https://cdn.pixabay.com/photo/2018/07/01/20/01/mercedes-3510327__340.jpg
https://cdn.pixabay.com/photo/2018/06/28/15/23/soft-fruits-3504149__340.jpg
https://cdn.pixabay.com/photo/2018/06/28/17/02/water-lily-3504363__340.jpg
https://cdn.pixabay.com/photo/2018/06/29/01/47/piano-3505109__340.jpg
</code></pre><h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h3><p>总的来说使用BeautifulSoup已经能够解决大部分爬虫问题了，但是由于BeautifulSoup的另辟蹊径，独创了一套正则表达式的查询方法导致了爬虫的爬取速度非常的慢，而且BeautifulSoup对于列表项的爬取是非常的糟糕的。但是lxml就不存在着两个问题，lxml由于底层采用c语言代码编写，所以速度上是非常快的。而且由于lxml采用xpath语法解析HTML，对列表项的爬取是非常轻松的。 </p>
<p>关于lxml框架和xpath语法，读者可以参看<a href="https://cuiqingcai.com/2621.html" target="_blank" rel="external">崔庆才的博客</a>。</p>
<p>下面使用lxml爬取pixabay网站图片url: </p>
<pre><code>import requests
from lxml import etree
# 获取网页的源代码
response = requests.get(&#39;https://pixabay.com/en/&#39;)
response.encoding = &#39;utf-8&#39;
html = response.text
# 解析网页
parser = etree.HTML(html)
for i in range(1,21): #打印前20张图片url
    link = parser.xpath(&#39;//*[@id=&quot;gallery&quot;]/div[1]/div[&#39;+ str(i) +&#39;]/a/img/@src&#39;)[0]
    print(link) 
</code></pre><p>运行结果： </p>
<pre><code>https://cdn.pixabay.com/photo/2018/06/23/16/22/romanesco-3493007__340.jpg
https://cdn.pixabay.com/photo/2018/07/08/14/16/cat-3523992__340.jpg
https://cdn.pixabay.com/photo/2018/05/30/15/31/rustic-3441673__340.jpg
https://cdn.pixabay.com/photo/2016/06/29/09/28/golf-1486354__340.jpg
https://cdn.pixabay.com/photo/2017/11/10/08/10/son-2935723__340.jpg
https://cdn.pixabay.com/photo/2018/07/06/13/30/statue-3520416__340.jpg
https://cdn.pixabay.com/photo/2018/07/08/15/32/dahlia-3524115__340.jpg
https://cdn.pixabay.com/photo/2018/05/07/22/08/sydney-opera-house-3381786__340.jpg
https://cdn.pixabay.com/photo/2018/07/05/23/31/ivy-3519431__340.jpg
https://cdn.pixabay.com/photo/2017/06/05/14/55/glass-2374311__340.jpg
https://cdn.pixabay.com/photo/2018/04/12/11/44/apple-3313225__340.jpg
https://cdn.pixabay.com/photo/2017/09/22/09/48/desert-2774945__340.jpg
https://cdn.pixabay.com/photo/2017/07/12/22/51/couple-2498660__340.jpg
https://cdn.pixabay.com/photo/2016/06/20/03/15/pier-1467984__340.jpg
https://cdn.pixabay.com/photo/2018/01/29/10/40/shower-of-sparks-3115784__340.jpg
https://cdn.pixabay.com/photo/2017/09/06/20/35/massage-2722936__340.jpg
https://cdn.pixabay.com/photo/2018/07/01/20/01/mercedes-3510327__340.jpg
https://cdn.pixabay.com/photo/2018/06/28/15/23/soft-fruits-3504149__340.jpg
https://cdn.pixabay.com/photo/2018/06/28/17/02/water-lily-3504363__340.jpg
https://cdn.pixabay.com/photo/2018/06/29/01/47/piano-3505109__340.jpg
</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="动态数据爬取"><a href="#动态数据爬取" class="headerlink" title="动态数据爬取"></a>动态数据爬取</h2><p>占位</p>
<h3 id="百度地图数据爬取"><a href="#百度地图数据爬取" class="headerlink" title="百度地图数据爬取"></a>百度地图数据爬取</h3><p>占位</p>
<h3 id="微博数据爬取实战"><a href="#微博数据爬取实战" class="headerlink" title="微博数据爬取实战"></a>微博数据爬取实战</h3><p>占位</p>
<h3 id="球探网数据爬取"><a href="#球探网数据爬取" class="headerlink" title="球探网数据爬取"></a>球探网数据爬取</h3><p>占位</p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>开源啦！60维维基百科词向量免费放送</title>
    <url>/2018/01/08/%E5%BC%80%E6%BA%90%E5%95%A6%EF%BC%8160%E7%BB%B4%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%AF%8D%E5%90%91%E9%87%8F%E5%85%8D%E8%B4%B9%E6%94%BE%E9%80%81/</url>
    <content><![CDATA[<h2 id="开源啦！60维维基百科词向量免费放送"><a href="#开源啦！60维维基百科词向量免费放送" class="headerlink" title="开源啦！60维维基百科词向量免费放送"></a>开源啦！60维维基百科词向量免费放送</h2><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>在本次开源数据中共包含4个文件，分别如下：<br>wiki.zh.text.model<br>wiki.zh.text.model.syn1neg.npy<br>wiki.zh.text.model.wv.syn0.npy<br>wiki.zh.text.vector<br>其中我们需要使用的仅有wiki.zh.text.model、wiki.zh.text.vector其余两个是numpy自动生成的数据。如果你的需求是计算词之间的距离，可以使用gensim包具体用法如下：</p>
<pre><code>import gensim #导入gensim包
model = gensim.models.Word2Vec.load(&quot;wiki.zh.text.model&quot;) #加载词向量模型
result = model.most_similar(u&#39;足球&#39;)
for each in result:
    print each[0] , each[1]
</code></pre><a id="more"></a>
<p>输出结果为：<br>国际足球 0.556692957878<br>足球运动 0.530436098576<br>篮球 0.518306851387<br>国家足球队 0.516140639782<br>足球队 0.513238489628<br>足球联赛 0.500901579857<br>football 0.500162124634<br>体育 0.499264538288<br>足球比赛 0.488131582737<br>冰球 0.48725092411</p>
<p>说明：前面的是和“足球”最相近的词，后面是相似度<br>更多gensim和词向量的用法请参考相关博客<br>下面是连接地址：<a href="https://pan.baidu.com/s/1o8f1ELs" target="_blank" rel="external">60维词向量</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>NLP</tag>
        <tag>word embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理入门实践</title>
    <url>/2017/11/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="自然语言处理入门实践"><a href="#自然语言处理入门实践" class="headerlink" title="自然语言处理入门实践"></a>自然语言处理入门实践</h2><blockquote>
<p>人工智能领域中有两个主流方向即机器视觉（CV）和自然语言处理（NLP）。其中自然语言处理（英语：Natural Language Processing，缩写作 NLP）是人工智能和语言学领域的分支学科。自然语言处理领域主要探讨如何处理及运用自然语言。自然语言处理包括多方面和步骤，基本有认知、理解、生成等部分。下面介绍一些NLP的基础知识。</p>
</blockquote>
<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>&emsp;&emsp;提到自然语言处理当然不得不提大名鼎鼎的自然语言处理工具包NLTK了。NLTK在国外很流行，它提供包括英文分词、词性标注、命名实体的识别等等自然语言处理中的基本操作。如果各位想体验NLTK你可以通过<code>pip install nltk</code>来安装nltk。<br>​&emsp;&emsp;但是nltk只支持英文分词，如果想对中文进行切词还得另谋他法。英文分词很方便，直接按照空格分割字符串就可以切出token字串，但是汉语是没有使用空格来分割词语。所以我给大家提供了一下几种汉语分词解决方案。  </p>
<ol>
<li>使用斯坦福大学分词器+nltk包，完美解决nltk对汉语的兼容。  </li>
<li>使用jieba分词。  </li>
<li>使用哈工大语言技术平台的python封装包pyltp  </li>
</ol>
<a id="more"></a>
<p>&emsp;&emsp;本人经常用的是jieba分词工具和哈工大的分词器pyltp。首先jieba分词工具分词的速度非常快，这一点可谓是完胜pyltp，而且jieba分词的准确率也和pyltp非常接近。但是jieba分词工具终究只是一个分词工具。它不支持一些高级的功能比如命名实体识别，语义角色标注等。所以如果只需要分词而不需要命名实体识别那就尽量使用jieba分词，有其它需求再使用pyltp。  </p>
<p>&emsp;&emsp;你可以通过pip安装jieba和pyltp，jieba的安装非常简单，使用一个pip安装就可以了。但是pyltp的安装就没那么容易了，你除了需要安装pyltp还需要下载一个数据包，这个数据包提供了分词需要的一些词典。为了下载这个数据包你需要去<a href="https://github.com/HIT-SCIR/pyltp" target="_blank" rel="external">Pyltp在Github主页</a>下载整个项目，然后把项目中的ltp_data文件夹存放到一个固定位置方便以后调用。另外pyltp的具体调用方法可以前往<a href="http://pyltp.readthedocs.io/zh_CN/develop/api.html" target="_blank" rel="external">Pyltp的官网</a>学习。jieba分词的调用方法可以直接前往它在<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">Github主页</a>查看。</p>
<p>下面我简单介绍一下jieba分词工具的使用： </p>
<p>代码： </p>
<pre><code># coding:utf-8
import jieba

text = &quot;青年一代有理想、有本领、有担当，国家就有前途，民族就有希望。&quot;
tokens = jieba.lcut(text)
print(tokens) 
</code></pre><p>运行结果： </p>
<pre><code>Building prefix dict from the default dictionary ...
Loading model from cache C:\temp\jieba.cache
Loading model cost 1.020 seconds.
Prefix dict has been built succesfully.
[&#39;青年一代&#39;, &#39;有&#39;, &#39;理想&#39;, &#39;、&#39;, &#39;有&#39;, &#39;本领&#39;, &#39;、&#39;, &#39;有&#39;, &#39;担当&#39;, &#39;，&#39;, &#39;国家&#39;, &#39;就&#39;, &#39;有&#39;, &#39;前途&#39;, &#39;，&#39;, &#39;民族&#39;, &#39;就&#39;, &#39;有&#39;, &#39;希望&#39;, &#39;。&#39;]
</code></pre><h2 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h2><p>&emsp;&emsp;什么是停用词呢？停用词就是在信息检索中，为节省存储空间和提高搜索效率，在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词，这些字或词即被称为停用词（Stop Words）。 这些停用词都是人工输入、非自动化生成的，生成后的停用词会形成一个停用词表。但是，并没有一个明确的停用词表能够适用于所有的工具。甚至有一些工具是明确地避免使用停用词来支持短语搜索的。 </p>
<p>&emsp;&emsp;简单来说就是对我们处理自然语言过程中没有帮助的词汇，例如“哈哈”、“不仅”、“如果”等。这些词蕴含的信息很少，所以在NLP中我们通常会将它们从分词结果中去掉。 </p>
<p>&emsp;&emsp;那么怎么获取停用词表呢？首先你可以谷歌一下，网上有很多停用词表。不过如果你想为了方便的话可以使用我提供给你的停用词表。<a href="https://pan.baidu.com/s/1o8VFnTK" target="_blank" rel="external">https://pan.baidu.com/s/1o8VFnTK</a><br>说明： </p>
<p>停用词表每一行就是一个停用词且该停用词表即包括标点符号也包括普通停用词。</p>
<p>那么有怎么去除停用词呢？ </p>
<p>你可以通过下面代码加载停用词，其中stopwords.txt就是停用词文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">stopwords = [line.strip() for line in open(&apos;stopwords.txt&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;).readlines()]</div></pre></td></tr></table></figure>
<h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>&emsp;&emsp;tf-idf（英语：term frequency–inverse document frequency）是一种用于信息检索与文本挖掘的常用加权技术。tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。 </p>
<p>&emsp;&emsp;tf是term frequency的缩写，也就是词频的意思；而idf是inverse document frequency的缩写，也就是逆词频的意思。 我大概解释一下，通常一个句子中不同的词蕴含着不同的信息，且他们的重要性是不相同的。通常一个词语在一个文本中出现的次数越高说明它就越重要，反之越不重要。这是有些细心的读者就发现了，我们前面介绍的那些停用词怎么解释，例如“不仅”，它在一个句子中出现的顺序其实也不低呀，如果我们认为它很重要的话，那么就大错特错了，因为它是不包含任何信息的。所以我们此时就引入下面一个概念，也就是逆词频。通常在多个文本中，我们认为当一个词在同一篇文本中出现的次数越高那么它就越重要，可是如果它即出现在本篇文档中又在其他文档中的频次很高，那么我们就认为它不那么重要了。我们需要降低它的重要程度。</p>
<p>对于在某一特定文件里的词语来说，它的重要性可表示为： </p>
<script type="math/tex; mode=display">
tf_{ij}=\frac{n_{i,j}}{\sum_kn_{k,j}}</script><p>逆向文件频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p>
<script type="math/tex; mode=display">
idf_i=\log \frac{|D|}{|{j:t_i\in d_j}|}</script><p>最后计算综合词频和逆词频得到最终的tfidf值</p>
<script type="math/tex; mode=display">
tfidf_{i,j}=tf_{i,j}\times idf_i</script><h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><h3 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h3><p>&emsp;&emsp;自然语言在计算机中是以字符或者字符串形式存在的，但是作为一个基于统计的机器学习系统，我们的运算对象是数值型的数据，所以我们需要对字符型数据进行处理。</p>
<p>&emsp;&emsp;表征单词的方式是首先建立一个较大的词汇表（例如10000），然后使用one-hot的方式对每个单词进行编码。例如单词Man，Woman，King，Queen，Apple，Orange分别出现在词汇表的第5391，9853，4914，7157，456，6257的位置，则它们分别用O5391,O9853,O4914,O7157,O456,O6257表示。其中O5391表示一个维度为10000，第5391维度的值为1其余位置值全为0的向量。</p>
<p>&emsp;&emsp;one-hot表征单词的方法最大的缺点就是每个单词都是独立的、正交的，无法知道不同单词之间的相似程度。例如Apple和Orange都是水果，词性相近，但是单从one-hot编码上来看，内积为零，无法知道二者的相似性。在NLP中，我们更希望能掌握不同单词之间的相似程度。</p>
<h3 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h3><p>&emsp;&emsp;为了解决One-hot向量的缺点我们可以使用特征表征（Featurized representation）的方法对每个单词进行编码。也就是使用一个特征向量表征单词，特征向量的每个元素都是对该单词某一特征的量化描述，量化范围可以是[-1,1]之间。特征表征的例子如下图所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Man(5391)</th>
<th style="text-align:center">Woman(9853)</th>
<th style="text-align:center">King(4914)</th>
<th style="text-align:center">Queen(7157)</th>
<th style="text-align:center">Apple(456)</th>
<th style="text-align:center">Orange(6257)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Gender</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-0.95</td>
<td style="text-align:center">0.97</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">0.01</td>
</tr>
<tr>
<td style="text-align:center">Royal</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">0.93</td>
<td style="text-align:center">0.95</td>
<td style="text-align:center">-0.01</td>
<td style="text-align:center">0.00</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">0.03</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.65</td>
<td style="text-align:center">0.03</td>
<td style="text-align:center">-0.02</td>
</tr>
<tr>
<td style="text-align:center">Food</td>
<td style="text-align:center">0.09</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.95</td>
<td style="text-align:center">0.97</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;特征向量的长度依情况而定，特征元素越多则对单词表征得越全面。这里的特征向量长度设定为300。使用特征表征之后，词汇表中的每个单词都可以使用对应的300 x 1的向量来表示，该向量的每个元素表示该单词对应的某个特征值。每个单词用e+词汇表索引的方式标记，例如e5391, e9853, e4914, e7157, e456, e6257。</p>
<p>&emsp;&emsp;特征表征的优点是根据特征向量能清晰知道不同单词之间的相似程度，例如Apple和Orange之间的相似度较高，很可能属于同一类别。这种单词“类别”化的方式，大大提高了有限词汇量的泛化能力。这种特征化单词的操作被称为Word Embeddings，即单词嵌入。</p>
<p>&emsp;&emsp;这里特征向量的每个特征元素含义是具体的，对应到实际特征，例如性别、年龄等。而在实际应用中，特征向量很多特征元素并不一定对应到有物理意义的特征，是比较抽象的。但是，这并不影响对每个单词的有效表征，同样能比较不同单词之间的相似性。</p>
<h3 id="学习词嵌入"><a href="#学习词嵌入" class="headerlink" title="学习词嵌入"></a>学习词嵌入</h3><p>我们可以通过构建自然语言模型（神经网络），运用梯度下降算法得到embedding。举个简单的例子，输入样本是下面这句话：<br>I want a glass of orange ——.<br>通过这句话的前6个单词，预测最后的单词“juice”。</p>
<p>为了让神经网络输入层数目固定，可以选择只取预测单词的前4个单词作为输入，例如该句中只选择“a glass of orange”四个单词作为输入。当然，这里的4是超参数，可调。</p>
<p>一般地，我们把输入叫做context，输出叫做target。对应到上面这句话里：</p>
<p>context: a glass of orange<br>target: juice</p>
<p>关于context的选择有多种方法：</p>
<ul>
<li>target前n个单词或后n个单词，n可调</li>
<li>target前1个单词</li>
<li>target附近某1个单词（Skip-Gram）</li>
</ul>
<p>关于context和target的选择，比较流行的模型有Skip-Gram和Cbow。</p>
<h2 id="情感分析"><a href="#情感分析" class="headerlink" title="情感分析"></a>情感分析</h2><p>pass</p>
<h2 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h2><p>pass</p>
<h2 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h2><p>pass</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>二级域名指向网站子目录的配置</title>
    <url>/2017/11/11/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91%E7%BD%91%E7%AB%99%E5%AD%90%E7%9B%AE%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="第一步：添加二级域名"><a href="#第一步：添加二级域名" class="headerlink" title="第一步：添加二级域名"></a>第一步：添加二级域名</h1><p>首先声明的是，我的wordpress保存在网站的根目录下的wordpress子目录，所以我现在想把wordpress目录指向二级域名blog.figurinn.xyz.经过多次尝试终于成功了。<br>首先，你需要在你申请域名的服务商那里新增二级域名。如果你是在阿里云申请的域名，那么你需要到阿里云的DNS解析里面找到新增DNS的按钮，纪录类型选择A，然后主机纪录填你想要申请的名称，例如我的就填blog，记录值就是你服务器的IP地址，其他的默认就好了。  </p>
<h1 id="第二步：服务器设置"><a href="#第二步：服务器设置" class="headerlink" title="第二步：服务器设置"></a>第二步：服务器设置</h1><p>这一步你需要在你的网站根目录下增加一个名叫.htaccess的文件，然后填入一下的内容  </p>
<pre><code>    &lt;IfModule mod_rewrite.c&gt;
    RewriteEngine On
    RewriteCond %{HTTP_HOST} ^blog.figurinn.xyz$
    RewriteCond %{REQUEST_URI} !^/wordpress/
    RewriteRule ^(.*)$ /wordpress/$1?Rewrite [L,QSA]
    &lt;/IfModule&gt;
</code></pre><a id="more"></a>
<p>上面的内容是根据我的网站设定的，你可以根据你的需求进行更改<br>如果你此时访问的二级域名不成功的话，很可能你没有开启服务器url重写功能。<br>如果这样，你可以按一下步骤打开服务器的url重写功能(以我的ubuntu服务器为例子)<br>首先确保/etc/apache2/mods-enabled/rewrite.load文件中的  </p>
<pre><code>    LoadModule rewrite_module /usr/lib/apache2/modules/mod_ rewrite.so
</code></pre><p>没有被注释掉（如果有#号表示就被注释），如果被注释了取消注释（只需要删除前面的#）即可，然后vim保存退出。<br>然后编辑/etc/apache2/apache2.conf 文件，找到  </p>
<pre><code>&lt;Directory /var/www/&gt;
Options Indexes FollowSymLinks
AllowOverride None
Require all granted
&lt;/Directory&gt;
</code></pre><p>然后将AllowOverride None中的None改为All<br>到此为止二级域名指向服务器子目录就成功了  </p>
<h1 id="一些问题及解决办法"><a href="#一些问题及解决办法" class="headerlink" title="一些问题及解决办法"></a>一些问题及解决办法</h1><p>我通过blog.figurinn.xyz设置二级域名指向子目录成功后，该二级域名可以访问，可是发现当访问某一篇文章时，却发现文章的前缀还是www.figurinn.xyz/wordpress，后来发现是wordpress设置的问题<br>如果你也有同样的问题，你可以进入wordpress后台，然后点击设置，你会发现有“WordPress地址”、“站点地址”，如果你希望访问wordpress中某一篇文章时url的前缀也是你设置的二级域名的话，你只需要将上文提到的两个设置选项设置为你的二级域名即可。</p>
]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3连接MySQL数据库</title>
    <url>/2017/09/17/Python3%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>Python2连接数据库一般使用mysqldb库，而到了Python3已经完全不支持mysqldb库了，所以要使用其他的替代库。而Django中又使用了mysqldb库，所以我们的解决方案就是使用pymysql库来模拟mysqldb库。 </p>
<p>先在python3中安装好pymysql库。然后在Django项目的app包的<strong>init</strong>.py文件中添加如下语句： </p>
<pre><code>    import pymysql
    pymysql.install_as_MySQLdb()
</code></pre><p>这样我们就可以在Django项目中调用mysql数据库了。<br><a id="more"></a></p>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python</tag>
        <tag>django</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈我对于维度的理解</title>
    <url>/2017/08/25/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E4%BA%8E%E7%BB%B4%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>&emsp;&emsp;前不久和朋友聊到了维度的话题，朋友给我讲了他在一本杂志上看到的有关空间维度的文章。身处在三维空间的我们是很难理解四维空间的，我们人类理解四维空间就好比二维空间的生物理解三维空间的生物一样困难。假如蚂蚁是一种二维生物，它的活动范围只能是地面（平面），而苍蝇就是生活在三维空间的生物，它可以向上下、左右、前后中的任意一个方向移动。假设某一天苍蝇突然从空中落下停到地面休息了几秒，这时二维生物蚂蚁发现了三维生物苍蝇，但是苍蝇转瞬即逝。这种现象其实有点类似人类发现不明飞行物。我们假设外星人生活在四维空间，它可以在时间轴上任意移动，而我们人类只能从某个时间点出发并且沿着时间增大的方向匀速移动。相比于四维空间的生物能够在时间轴上以任意方向任意速度移动而言，我们三维空间的生物可能显得有点笨拙。经过这样的解释，那么经常出现在新闻版面中的不明飞行物转瞬即逝的现象就能够很好解释了。 </p>
<p>&emsp;&emsp;关于维度的认知霍金曾在他的著作《时间简史》中做出过这样的理解：维度可以比喻成驾驶火车，一维世界的火车只能笔直的往前行驶，二维的火车除了可以向前行驶之外还可以转弯，而三维世界的火车除了具有以上的特质外，遇到有坡度的山还可以向上行驶。如果存在四维空间的火车，那它就可以做时间旅行了，所以我认为外星人如果存在的话应该就存在于四维空间。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>空间维度</tag>
      </tags>
  </entry>
</search>
